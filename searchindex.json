{"categories":[{"title":"杂技浅尝","uri":"https://wangzeping722.github.io/categories/%E6%9D%82%E6%8A%80%E6%B5%85%E5%B0%9D/"}],"posts":[{"content":" DNS 有多种记录类型，每种记录都有不同的作用，这篇文章主要总结了常用的记录。\nA A（Address）记录用来指定主机名（域名）对应的 IPv4 地址记录。比如，当你浏览一个网页时候会，浏览器就会先去查找对应域名的 A 记录，来获取 IP 地址，获得了 IP 地址，才能与服务器建立连接。\n 我们可以为同一个域名添加多个 A 记录，解析的时候，会得到多个 IP，会随机选择一个使用。\n 域名不区分大小写。记录的名称应该是由 ASCII 码字母、数字和 - 组成。\nAAAA AAAA 记录用来指定主机名（域名）对应的 IPv6 地址记录，其他与 A 相同。\nCNAME （canonical names） CNAME（规范名称），也就是别名记录，它能够让我们把多个名字映射到同一个主机。\n应用场景：\n 使用 CDN 服务时。 假如一个服务器运行着 100 个网站，这 100 个网站 CNAME 到 a.example.com。当该服务器 IP 改变时，你只需改变 a.example.com的 IP 就可以了。  注意：由于CNAME记录就是一个替换，所以域名一旦设置CNAME记录以后，就不能再设置其他记录了（比如A记录和MX记录），这是为了防止产生冲突。举例来说，foo.com指向bar.com，而两个域名各有自己的MX记录，如果两者不一致，就会产生问题。由于顶级域名通常要设置MX记录，所以一般不允许用户对顶级域名设置CNAME记录。\nA记录是把域名解析到IP地址，而CNAME记录是把域名解析到另外一个域名，而这个域名最终会指向A记录，在功能实现在上A记录与CNAME记录没有区别。\n例如：\na.example.com IN A 192.168.1.101 b.example.com IN CNAME a.example.com（规范名称）  你在请求 b.example.com 的时候，他会先返回给你一个 CNAME ，然后你在用 CNAME 去查询。\nNS NS（Name Server），域名服务器记录，返回保存下一级域名信息的服务器地址。该记录只能设置为域名，不能设置为IP地址。\n一般来说，为了服务的安全可靠，至少应该有两条NS记录，而A记录和MX记录也可以有多条，这样就提供了服务的冗余性，防止出现单点失败。\n$ dig NS google.com google.com.\t777\tIN\tNS\tns4.google.com. google.com.\t777\tIN\tNS\tns3.google.com. google.com.\t777\tIN\tNS\tns2.google.com. google.com.\t777\tIN\tNS\tns1.google.com.  我们可以看见，google 的权威 NS 服务器有四个。\nMX MX（MX record），邮件交换记录，用于邮件服务器的地址。MX 记录允许设置优先级，当多个邮件服务器可用时，会根据该值决定投递邮件的服务器（值小的优先），下面的20, 10, 40 ...就表示优先级。\n$ dig MX google.com google.com.\t306\tIN\tMX\t20 alt1.aspmx.l.google.com. google.com.\t306\tIN\tMX\t10 aspmx.l.google.com. google.com.\t306\tIN\tMX\t40 alt3.aspmx.l.google.com. google.com.\t306\tIN\tMX\t30 alt2.aspmx.l.google.com. google.com.\t306\tIN\tMX\t50 alt4.aspmx.l.google.com.  SOA SOA 叫做起始授权机构记录，NS用于标识多台域名解析服务器，SOA记录用于在众多NS记录中的主服务器。SOA 记录表示此域名的权威解析服务器地址。 当要查询的域名在所有递归解析服务器中没有域名解析的缓存时，就会回源来请求此域名的SOA记录，也叫权威解析记录。\n没有SOA记录的 zone 不符合 RFC 1035 要求的标准。\n$TTL 86400 @ IN SOA startech60serve root.startech60serve.com. ( 2018110201 ;Serial 3600 ;Refresh 1800 ;Retry 604800 ;Expire 86400 ;Minimum TTL ) IN NS startech60serve IN A 192.168.1.3 IN MX 10 startech60serve startech60serve IN A 192.168.1.3  root.startech60serve.com.其中第一个点表示是@\nTXT TXT（TXT record），文本记录，一般用来描述一个域名，或者用来做某种验证功能，例如：\n$ dig TXT google.com google.com.\t300\tIN\tTXT\t\u0026quot;docusign=05958488-4752-4ef2-95eb-aa7ba8a3bd0e\u0026quot; google.com.\t3600\tIN\tTXT\t\u0026quot;facebook-domain-verification=22rm551cu4k0ab0bxsw536tlds4h95\u0026quot; google.com.\t300\tIN\tTXT\t\u0026quot;docusign=1b0a6754-49b1-4db5-8540-d2c12664b289\u0026quot; google.com.\t3600\tIN\tTXT\t\u0026quot;globalsign-smime-dv=CDYX+XFHUw2wml6/Gb8+59BsH31KzUr6c1l2BPvqKX8=\u0026quot; google.com.\t3600\tIN\tTXT\t\u0026quot;v=spf1 include:_spf.google.com ~all\u0026quot;  PTR PTR 记录是 A 记录的逆向记录，又称做 IP 反查记录或指针记录，负责将 IP 反向解析为域名，即反向域名解析。\n参考：\nhttps://skyao.io/learning-dns/dns/\nhttps://deepzz.com/post/dns-recording-type.html\n","id":0,"section":"posts","summary":"DNS 有多种记录类型，每种记录都有不同的作用，这篇文章主要总结了常用的记录。 A A（Address）记录用来指定主机名（域名）对应的 IPv4 地址记录。比","tags":null,"title":"DNS学习总结","uri":"https://wangzeping722.github.io/2019/12/dns-recording/","year":"2019"},{"content":" 最近在看coredns的实现，它是基于 caddy 框架实现的，充分利用了 caddy 的插件功能。由于 coredns 大多数功能都是利用插件功能来实现的，所以整个项目的代码理解起来都比较简单。\nCoreDNS 的实现 首先来看根目录下的 Makefile ，其中有自动生成 core/plugin/zplugin.go 文件和 core/dnsserver/zdirectives.go 文件的命令：\ncore/plugin/zplugin.go core/dnsserver/zdirectives.go: plugin.cfg go generate coredns.go  该命令可以通过 plugin.cfg 中列出的插件列表自动生成 zplugin.go 和 zdirectives.go 中的代码：\n// generated by directives_generate.go; DO NOT EDIT package plugin import ( // Include all plugins. _ \u0026quot;github.com/caddyserver/caddy/onevent\u0026quot; _ \u0026quot;github.com/coredns/coredns/plugin/acl\u0026quot; _ \u0026quot;github.com/coredns/coredns/plugin/any\u0026quot; _ \u0026quot;github.com/coredns/coredns/plugin/auto\u0026quot; _ \u0026quot;github.com/coredns/coredns/plugin/autopath\u0026quot; _ \u0026quot;github.com/coredns/coredns/plugin/azure\u0026quot; _ \u0026quot;github.com/coredns/coredns/plugin/bind\u0026quot; _ \u0026quot;github.com/coredns/coredns/plugin/bufsize\u0026quot; _ \u0026quot;github.com/coredns/coredns/plugin/cache\u0026quot; _ \u0026quot;github.com/coredns/coredns/plugin/cancel\u0026quot; _ \u0026quot;github.com/coredns/coredns/plugin/chaos\u0026quot; _ \u0026quot;github.com/coredns/coredns/plugin/clouddns\u0026quot; _ \u0026quot;github.com/coredns/coredns/plugin/debug\u0026quot; _ \u0026quot;github.com/coredns/coredns/plugin/dnssec\u0026quot; _ \u0026quot;github.com/coredns/coredns/plugin/dnstap\u0026quot; _ \u0026quot;github.com/coredns/coredns/plugin/erratic\u0026quot; _ \u0026quot;github.com/coredns/coredns/plugin/errors\u0026quot; _ \u0026quot;github.com/coredns/coredns/plugin/etcd\u0026quot; _ \u0026quot;github.com/coredns/coredns/plugin/file\u0026quot; _ \u0026quot;github.com/coredns/coredns/plugin/forward\u0026quot; _ \u0026quot;github.com/coredns/coredns/plugin/grpc\u0026quot; _ \u0026quot;github.com/coredns/coredns/plugin/health\u0026quot; _ \u0026quot;github.com/coredns/coredns/plugin/hosts\u0026quot; _ \u0026quot;github.com/coredns/coredns/plugin/k8s_external\u0026quot; _ \u0026quot;github.com/coredns/coredns/plugin/kubernetes\u0026quot; _ \u0026quot;github.com/coredns/coredns/plugin/loadbalance\u0026quot; _ \u0026quot;github.com/coredns/coredns/plugin/log\u0026quot; _ \u0026quot;github.com/coredns/coredns/plugin/loop\u0026quot; _ \u0026quot;github.com/coredns/coredns/plugin/metadata\u0026quot; _ \u0026quot;github.com/coredns/coredns/plugin/metrics\u0026quot; _ \u0026quot;github.com/coredns/coredns/plugin/nsid\u0026quot; _ \u0026quot;github.com/coredns/coredns/plugin/pprof\u0026quot; _ \u0026quot;github.com/coredns/coredns/plugin/ready\u0026quot; _ \u0026quot;github.com/coredns/coredns/plugin/reload\u0026quot; _ \u0026quot;github.com/coredns/coredns/plugin/rewrite\u0026quot; _ \u0026quot;github.com/coredns/coredns/plugin/root\u0026quot; _ \u0026quot;github.com/coredns/coredns/plugin/route53\u0026quot; _ \u0026quot;github.com/coredns/coredns/plugin/secondary\u0026quot; _ \u0026quot;github.com/coredns/coredns/plugin/sign\u0026quot; _ \u0026quot;github.com/coredns/coredns/plugin/template\u0026quot; _ \u0026quot;github.com/coredns/coredns/plugin/tls\u0026quot; _ \u0026quot;github.com/coredns/coredns/plugin/trace\u0026quot; _ \u0026quot;github.com/coredns/coredns/plugin/transfer\u0026quot; _ \u0026quot;github.com/coredns/coredns/plugin/whoami\u0026quot; _ \u0026quot;github.com/coredns/federation\u0026quot; )  // generated by directives_generate.go; DO NOT EDIT package dnsserver var Directives = []string{ \u0026quot;metadata\u0026quot;, \u0026quot;cancel\u0026quot;, \u0026quot;tls\u0026quot;, \u0026quot;reload\u0026quot;, \u0026quot;nsid\u0026quot;, \u0026quot;bufsize\u0026quot;, \u0026quot;root\u0026quot;, \u0026quot;bind\u0026quot;, \u0026quot;debug\u0026quot;, \u0026quot;trace\u0026quot;, \u0026quot;ready\u0026quot;, \u0026quot;health\u0026quot;, \u0026quot;pprof\u0026quot;, \u0026quot;prometheus\u0026quot;, \u0026quot;errors\u0026quot;, \u0026quot;log\u0026quot;, \u0026quot;dnstap\u0026quot;, \u0026quot;acl\u0026quot;, \u0026quot;any\u0026quot;, \u0026quot;chaos\u0026quot;, \u0026quot;loadbalance\u0026quot;, \u0026quot;cache\u0026quot;, \u0026quot;rewrite\u0026quot;, \u0026quot;dnssec\u0026quot;, \u0026quot;autopath\u0026quot;, \u0026quot;template\u0026quot;, \u0026quot;transfer\u0026quot;, \u0026quot;hosts\u0026quot;, \u0026quot;route53\u0026quot;, \u0026quot;azure\u0026quot;, \u0026quot;clouddns\u0026quot;, \u0026quot;federation\u0026quot;, \u0026quot;k8s_external\u0026quot;, \u0026quot;kubernetes\u0026quot;, \u0026quot;file\u0026quot;, \u0026quot;auto\u0026quot;, \u0026quot;secondary\u0026quot;, \u0026quot;etcd\u0026quot;, \u0026quot;loop\u0026quot;, \u0026quot;forward\u0026quot;, \u0026quot;grpc\u0026quot;, \u0026quot;erratic\u0026quot;, \u0026quot;whoami\u0026quot;, \u0026quot;on\u0026quot;, \u0026quot;sign\u0026quot;, }  这些代码的作用将在后面解释。\nmain函数 我们先看 coredns.go 中的 main 函数：\npackage main //go:generate go run directives_generate.go //go:generate go run owners_generate.go import ( \u0026quot;github.com/coredns/coredns/coremain\u0026quot; // 初始化所有插件 _ \u0026quot;github.com/coredns/coredns/core/plugin\u0026quot; ) func main() { coremain.Run() }  想必大家都很熟悉 _ \u0026quot;github.com/coredns/coredns/core/plugin\u0026quot; 这一用法，目的就是想执行包 github.com/coredns/coredns/core/plugin 里的 init 函数。这时再回头看看 core/plugin/zplugin.go 中的代码，原来它又接着导入了所有在 plugin.cfg 中声明的插件的包，并且执行包里的 init 函数。这就使得所有的插件都会在 caddy 中注册自己，例如插件 file 的注册如下：\ncaddy.Plugin 结构包含了被注册的插件的基本信息,包括注册的服务类型(在CoreDNS中的服务类型是 dns )和请求这个插件时,这个插件该做的 Action。\n// Plugin is a type which holds information about a plugin. type Plugin struct { // ServerType is the type of server this plugin is for. // Can be empty if not applicable, or if the plugin // can associate with any server type. ServerType string // Action is the plugin's setup function, if associated // with a directive in the Caddyfile. Action SetupFunc }  caddy.RegisterPlugin方法的作用:\n将指定plugin name(本示例:kubernetes)注册到服务类型为DNS的CoreDNS服务中。最终所有被注册plugin的存储结构为:\n// plugins is a map of server type to map of plugin name to // Plugin. These are the \u0026quot;general\u0026quot; plugins that may or may // not be associated with a specific server type. If it's // applicable to multiple server types or the server type is // irrelevant, the key is empty string (\u0026quot;\u0026quot;). But all plugins // must have a name. plugins = make(map[string]map[string]Plugin)  因此，通过上面的这个过程就把CoreDNS需要的所有的plugin都注册到了 plugins = make(map[string]map[string]Plugin) 结构中，用于后续的使用。\n注册完所有的 plugin 之后，就开始执行 main 方法。接着会去调用 coremain.Run() 函数，通过 Run 方法进入 CoreDNS 的初始化过程。需要注意的是，run.go 引入了包 github.com/coredns/coredns/core/dnsserver ，里面也包含了init 方法：\nconst serverType = \u0026quot;dns\u0026quot; // Any flags defined here, need to be namespaced to the serverType other // wise they potentially clash with other server types. func init() { flag.StringVar(\u0026amp;Port, serverType+\u0026quot;.port\u0026quot;, DefaultPort, \u0026quot;Default port\u0026quot;) caddy.RegisterServerType(serverType, caddy.ServerType{ Directives: func() []string { return Directives }, DefaultInput: func() caddy.Input { return caddy.CaddyfileInput{ Filepath: \u0026quot;Corefile\u0026quot;, Contents: []byte(\u0026quot;.:\u0026quot; + Port + \u0026quot; {\\nwhoami\\nlog\\n}\\n\u0026quot;), ServerTypeName: serverType, } }, NewContext: newContext, }) }  这里会向 caddy 注册一个名为 dns 的服务类型，并关联与这个 dns 服务类型相关的一些操作和信息，包括：\n 插件的执行顺序 默认配置文件 newContext就是dnsContext对象，实现了 caddy 的 Context 接口  进入 run.go 的 init 函数，这里以注释的形式展示：\nfunc init() { // 默认配置文件 caddy.DefaultConfigFile = \u0026quot;Corefile\u0026quot; caddy.Quiet = true // don't show init stuff from caddy setVersion()\t// 设置版本信息 // 指定需要加载的配置文件 flag.StringVar(\u0026amp;conf, \u0026quot;conf\u0026quot;, \u0026quot;\u0026quot;, \u0026quot;Corefile to load (default \\\u0026quot;\u0026quot;+caddy.DefaultConfigFile+\u0026quot;\\\u0026quot;)\u0026quot;) flag.BoolVar(\u0026amp;plugins, \u0026quot;plugins\u0026quot;, false, \u0026quot;List installed plugins\u0026quot;) // 需要将PIDfile写入的地址 flag.StringVar(\u0026amp;caddy.PidFile, \u0026quot;pidfile\u0026quot;, \u0026quot;\u0026quot;, \u0026quot;Path to write pid file\u0026quot;) flag.BoolVar(\u0026amp;version, \u0026quot;version\u0026quot;, false, \u0026quot;Show version\u0026quot;) flag.BoolVar(\u0026amp;dnsserver.Quiet, \u0026quot;quiet\u0026quot;, false, \u0026quot;Quiet mode (no initialization output)\u0026quot;) // 与加载配置文件有关 caddy.RegisterCaddyfileLoader(\u0026quot;flag\u0026quot;, caddy.LoaderFunc(confLoader)) caddy.SetDefaultCaddyfileLoader(\u0026quot;default\u0026quot;, caddy.LoaderFunc(defaultLoader)) caddy.AppName = coreName caddy.AppVersion = CoreVersion }  做了那么多准备工作，终于要进入主方法了，我们来看 run.go 中的 Run 方法：\n其他的代码我们就不关心了，直接看 :\ncorefile, err := caddy.LoadCaddyfile(serverType)  该函数主要就是利用 coredns 注册的两个方法解析并加载配置文件到 corefile中，corefile 对应的结构体定义如下：\n// Input represents a Caddyfile; its contents and file path // (which should include the file name at the end of the path). // If path does not apply (e.g. piped input) you may use // any understandable value. The path is mainly used for logging, // error messages, and debugging. type Input interface { // Gets the Caddyfile contents Body() []byte // Gets the path to the origin file Path() string // The type of server this input is intended for ServerType() string }  有了 corefile 我们就能够启动服务器啦：\ninstance, err := caddy.Start(corefile)  Start 的细节我们接下来再说，我们先把主流程看完，Start 会返回一个 instance 结构，其包含了服务的状态，并且可以用来控制和访问这些服务：\n// Instance contains the state of servers created as a result of // calling Start and can be used to access or control those servers. // It is literally an instance of a server type. Instance values // should NOT be copied. Use *Instance for safety. type Instance struct { // serverType is the name of the instance's server type serverType string // caddyfileInput is the input configuration text used for this process caddyfileInput Input // wg is used to wait for all servers to shut down wg *sync.WaitGroup // context is the context created for this instance, // used to coordinate the setting up of the server type context Context // servers is the list of servers with their listeners servers []ServerListener // these callbacks execute when certain events occur OnFirstStartup []func() error // starting, not as part of a restart OnStartup []func() error // starting, even as part of a restart OnRestart []func() error // before restart commences OnRestartFailed []func() error // if restart failed OnShutdown []func() error // stopping, even as part of a restart OnFinalShutdown []func() error // stopping, not as part of a restart // storing values on an instance is preferable to // global state because these will get garbage- // collected after in-process reloads when the // old instances are destroyed; use StorageMu // to access this value safely Storage map[interface{}]interface{} StorageMu sync.RWMutex } // ServerListener pairs a server to its listener and/or packetconn. type ServerListener struct { server Server listener net.Listener packet net.PacketConn } type Server interface { TCPServer UDPServer }   serverType：表示该 instance 的服务类型，在 coredns 中是 dns caddyfileInput：表示配置文件 wg：wg 用来等待所有的服务器关闭 context：启动服务时需要的一些上下文配置，在 coredns 中，这个 context 就是 dnsContext servers：该 instance 需要启动的服务列表，从上面的代码中可以看出，主要是 TCP 和 UDP 服务。 Onxxx：on 开头的方法可以看成当特定事件发生时候的回调函数 Storage：用来存储全局状态  然后主函数阻塞在instance.Wait()上面。\n接下来，我们来看 Start 函数：\n// Start starts Caddy with the given Caddyfile. // // This function blocks until all the servers are listening. func Start(cdyfile Input) (*Instance, error) { inst := \u0026amp;Instance{serverType: cdyfile.ServerType(), wg: new(sync.WaitGroup), Storage: make(map[interface{}]interface{})} err := startWithListenerFds(cdyfile, inst, nil) if err != nil { return inst, err } signalSuccessToParent() if pidErr := writePidFile(); pidErr != nil { log.Printf(\u0026quot;[ERROR] Could not write pidfile: %v\u0026quot;, pidErr) } // Execute instantiation events EmitEvent(InstanceStartupEvent, inst) return inst, nil }  可以看见，他首先初始化了一个 Instance 结构体，在该函数中主要调用三个函数分别是:\n startWithListenerFds: 用于解析 Corefile 配置文件及校验指令执行的是否正确，并启动CoreDNS服务。 signalSuccessToParent: 向父进程报告服务启动状态。 writePidFile: 将启动服务的进程 ID(PID) 写入到指定的文件。  从上面的解释中即可知道 startWithListenerFds 是最为核心的函数调用了，接下来直接详细的分析startWithListenerFds 函数。在该函数中首先会调用\nerr = ValidateAndExecuteDirectives(cdyfile, inst, false)  从名字就可以看出这个函数的主要功能就是验证和执行指令（也就是插件），首先他会调用\nsblocks, err := loadServerBlocks(stypeName, cdyfile.Path(), bytes.NewReader(cdyfile.Body()))  来解析配置文件中的内容，如果配置文件中出现了coredns无法识别的插件，那么就会直接返回错误，程序终止，如果解析成功，那么就会把配置文件中的内容映射到 ServerBlock 结构体中：\n// ServerBlock associates any number of keys (usually addresses // of some sort) with tokens (grouped by directive name). type ServerBlock struct { Keys []string Tokens map[string][]Token }  其中，keys 用来存储配置文件中 Zone 的相关数据，而 Tokens 则用来存储该 server 中的插件的相关信息，其中 Tokens 的 key 是 plugin name , []Token 存储的是该 plugin 在 Corefile 中的位置，便于后续的解析操作。可能不太好理解，但是对应配置文件就非常好理解啦：\n// coredns.io:5300 为 keys coredns.io:5300 { file db.coredns.io } example.io:53 { log errors file db.example.io } example.net:53 { file db.example.net } .:53 { kubernetes proxy . 8.8.8.8 log errors cache }  如上图，对应的 zone 就是 example.io:53，其中包含三个插件，所以 Tokens 有三个元素，其中 file 插件对应的value 的长度为 2。\n接着，会调用\ninst.context = stype.NewContext(inst)  这里的 stype.NewContext 就是在初始化阶段赋值给他的 newContext函数：\nfunc newContext(i *caddy.Instance) caddy.Context { return \u0026amp;dnsContext{keysToConfigs: make(map[string]*Config)} } // dnsContext // 实现了caddy.Context接口 type dnsContext struct { keysToConfigs map[string]*Config // configs is the master list of all site configs. // configs是所有站点配置的主列表。 configs []*Config } Context interface { // Called after the Caddyfile is parsed into server // blocks but before the directives are executed, // this method gives you an opportunity to inspect // the server blocks and prepare for the execution // of directives. Return the server blocks (which // you may modify, if desired) and an error, if any. // The first argument is the name or path to the // configuration file (Caddyfile). // // This function can be a no-op and simply return its // input if there is nothing to do here. InspectServerBlocks(string, []caddyfile.ServerBlock) ([]caddyfile.ServerBlock, error) // This is what Caddy calls to make server instances. // By this time, all directives have been executed and, // presumably, the context has enough state to produce // server instances for Caddy to start. MakeServers() ([]Server, error) }  所以，创建一个实现了 caddy.Context 接口的 dnsContext结构体，并赋值给 instance.Context，然后调用 Context 的接口方法 InspectServerBlocks ，这个函数会在解析完Corefile文件之后，执行Corefile中的指令之前会被调用，用于进一步的对 sblocks 进行检查并进行进一步的参数完善。：\nsblocks, err = inst.context.InspectServerBlocks(cdyfile.Path(), sblocks)  等上面的准备工作准备完成之后，会调用executeDirectives去遍历所有的指令directives,并执行每个 sblocks 中的指令,并设置相应的 Controller 去执行相关 plugin 的 action 动作, 每个 serverblock 中的插件的 setup 只执行一次:\nfunc executeDirectives(inst *Instance, filename string, directives []string, sblocks []caddyfile.ServerBlock, justValidate bool) error { // map of server block ID to map of directive name to whatever. storages := make(map[int]map[string]interface{}) // It is crucial that directives are executed in the proper order. // We loop with the directives on the outer loop so we execute // a directive for all server blocks before going to the next directive. // This is important mainly due to the parsing callbacks (below). for _, dir := range directives { for i, sb := range sblocks { var once sync.Once if _, ok := storages[i]; !ok { storages[i] = make(map[string]interface{}) } for j, key := range sb.Keys { // Execute directive if it is in the server block if tokens, ok := sb.Tokens[dir]; ok { controller := \u0026amp;Controller{ instance: inst, Key: key, Dispenser: caddyfile.NewDispenserTokens(filename, tokens), OncePerServerBlock: func(f func() error) error { var err error once.Do(func() { err = f() }) return err }, ServerBlockIndex: i, ServerBlockKeyIndex: j, ServerBlockKeys: sb.Keys, ServerBlockStorage: storages[i][dir], } setup, err := DirectiveAction(inst.serverType, dir) if err != nil { return err } err = setup(controller) if err != nil { return err } storages[i][dir] = controller.ServerBlockStorage // persist for this server block } } } if !justValidate { // See if there are any callbacks to execute after this directive if allCallbacks, ok := parsingCallbacks[inst.serverType]; ok { callbacks := allCallbacks[dir] for _, callback := range callbacks { if err := callback(inst.context); err != nil { return err } } } } } return nil }  执行完了 ValidateAndExecuteDirectives 函数，就意味着所有的插件都已经准备完毕，接着调用 MakeServers返回一个服务器列表：\nslist, err := inst.context.MakeServers()  我们深入进去会发现，这个方法其实非常简单：\n// MakeServers uses the newly-created siteConfigs to create and return a list of server instances. func (h *dnsContext) MakeServers() ([]caddy.Server, error) { // Now that all Keys and Directives are parsed and initialized // lets verify that there is no overlap on the zones and addresses to listen for errValid := h.validateZonesAndListeningAddresses() if errValid != nil { return nil, errValid } // we must map (group) each config to a bind address groups, err := groupConfigsByListenAddr(h.configs) if err != nil { return nil, err } // then we create a server for each group var servers []caddy.Server for addr, group := range groups { // switch on addr switch tr, _ := parse.Transport(addr); tr { case transport.DNS: s, err := NewServer(addr, group) if err != nil { return nil, err } servers = append(servers, s) case transport.TLS: s, err := NewServerTLS(addr, group) if err != nil { return nil, err } servers = append(servers, s) case transport.GRPC: s, err := NewServergRPC(addr, group) if err != nil { return nil, err } servers = append(servers, s) case transport.HTTPS: s, err := NewServerHTTPS(addr, group) if err != nil { return nil, err } servers = append(servers, s) } } return servers, nil }  首先，它验证是否有端口冲突（同一zone，并且同一端口才算冲突），然后再根据 dnsContext 中的 configs生成不同的 group，根据监听的端口不同被分到不同的 group，最后返回一个 groups，之后遍历该 groups, 然后根据不同的 transport 去启动相应的服务，当前 CoreDNS 支持4种类型的 transport，默认情况下都是 DNS 。\n但是，无论哪种 transport 最终都会调用 NewServer：\nfunc NewServer(addr string, group []*Config) (*Server, error) { s := \u0026amp;Server{ Addr: addr, zones: make(map[string]*Config), graceTimeout: 5 * time.Second, } for _, site := range group { s.zones[site.Zone] = site // compile custom plugin for everything var stack plugin.Handler for i := len(site.Plugin) - 1; i \u0026gt;= 0; i-- { stack = site.Plugin[i](stack) // register the *handler* also site.registerHandler(stack) if s.trace == nil \u0026amp;\u0026amp; stack.Name() == \u0026quot;trace\u0026quot; { // we have to stash away the plugin, not the // Tracer object, because the Tracer won't be initialized yet if t, ok := stack.(trace.Trace); ok { s.trace = t } } // Unblock CH class queries when any of these plugins are loaded. if _, ok := EnableChaos[stack.Name()]; ok { s.classChaos = true } } site.pluginChain = stack } return s, nil }  由于代码过长，只看重点部分，先创建了一个 Server 变量，然后遍历 group ，并将每个 site 对应的 plugins 以栈的形式组成 pluginChain，最后返回。\n上面只是make了CoreDNS需要启动的Server结构,但是真正的服务进程到现在这个阶段还没有真正的启动。当所有的 plugin 需要的准备工作都处理完成之后，就调用startServers来启动CoreDNS服务,startServers函数的定义如下:\nfunc startServers(serverList []Server, inst *Instance, restartFds map[string]restartTriple) error { for _, s := range serverList { var ( ln net.Listener pc net.PacketConn err error ) ...... ...... if ln == nil { ln, err = s.Listen() if err != nil { return fmt.Errorf(\u0026quot;Listen: %v\u0026quot;, err) } } if pc == nil { pc, err = s.ListenPacket() if err != nil { return fmt.Errorf(\u0026quot;ListenPacket: %v\u0026quot;, err) } } inst.servers = append(inst.servers, ServerListener{server: s, listener: ln, packet: pc}) } for _, s := range inst.servers { inst.wg.Add(2) stopWg.Add(2) func(s Server, ln net.Listener, pc net.PacketConn, inst *Instance) { go func() { defer func() { inst.wg.Done() stopWg.Done() }() errChan \u0026lt;- s.Serve(ln) }() go func() { defer func() { inst.wg.Done() stopWg.Done() }() errChan \u0026lt;- s.ServePacket(pc) }() }(s.server, s.listener, s.packet, inst) } // Log errors that may be returned from Serve() calls, // these errors should only be occurring in the server loop. go func() { for { select { case err := \u0026lt;-errChan: if err != nil { if !strings.Contains(err.Error(), \u0026quot;use of closed network connection\u0026quot;) { // this error is normal when closing the listener; see https://github.com/golang/go/issues/4373 log.Println(err) } } case \u0026lt;-stopChan: return } } }() go func() { stopWg.Wait() stopChan \u0026lt;- struct{}{} }() return nil } // Serve starts the server with an existing listener. It blocks until the server stops. // This implements caddy.TCPServer interface. func (s *Server) Serve(l net.Listener) error { s.m.Lock() s.server[tcp] = \u0026amp;dns.Server{Listener: l, Net: \u0026quot;tcp\u0026quot;, Handler: dns.HandlerFunc(func(w dns.ResponseWriter, r *dns.Msg) { ctx := context.WithValue(context.Background(), Key{}, s) s.ServeDNS(ctx, w, r) })} s.m.Unlock() return s.server[tcp].ActivateAndServe() } // ServePacket starts the server with an existing packetconn. It blocks until the server stops. // This implements caddy.UDPServer interface. func (s *Server) ServePacket(p net.PacketConn) error { s.m.Lock() s.server[udp] = \u0026amp;dns.Server{PacketConn: p, Net: \u0026quot;udp\u0026quot;, Handler: dns.HandlerFunc(func(w dns.ResponseWriter, r *dns.Msg) { ctx := context.WithValue(context.Background(), Key{}, s) s.ServeDNS(ctx, w, r) })} s.m.Unlock() return s.server[udp].ActivateAndServe() }  同样省略部分代码，首先遍历 serverList ，并且生成 inst.servers 列表，然后再遍历 inst.servers 列表，启动协程分别监听 TCP 和 UDP，并且分别调用各自内部的 ServeDNS 来进行服务。\n走到这里，启动流程算是彻底走完了。\n总结 CoreDNS 代码的结构非常清晰，通过初始化时加载自定义的插件顺序，依次注入到 caddy 中去，并在执行的时候，按照定义的插件顺序依次执行，形成一个链式的调用结构。CoreDNS 同样还支持多种协议供使用者选择，这是一个非常好的实现。\n参考：\n CoreDNS源码分析 CoreDNS源码分析  ","id":1,"section":"posts","summary":"最近在看coredns的实现，它是基于 caddy 框架实现的，充分利用了 caddy 的插件功能。由于 coredns 大多数功能都是利用插件功能来实现的，所以整个项目的代码理解","tags":["coredns"],"title":"Coredns 启动流程分析","uri":"https://wangzeping722.github.io/2019/12/coredns-startup/","year":"2019"},{"content":" 1. 调研 前端：了解到有一个非常优秀的开源web终端库： xterm.js , 使用起来也比较简单。\n后端：使用 go 语言实现，因为 go 语言拥有许多优秀的开源ssh库，能够满足我们的需求。\n难点：\n1. 如何与 cf(cloud foundry) 进行交互得到 `ssh code` ？ 2. 如何把 ssh 命令行转换成 websocket 通讯, 并输出到 xterm.js 中？ 3. 如何控制访问权限？  2. 原理 ​ 1. 浏览器向服务器发起 websocket 请求\n​ 2. 服务器通过 ssh 连接到 cf 容器\n​ 3. 连接建立，服务器负责转发消息\n在后端和浏览器之间建立websocket连接后，将用户在浏览器中输入的命令通过 websocket 协议发送到后端，后端使用 ssh 协议将命令输入到容器ssh进程的 stdin，命令执行后，再从 stdout 中读取输出，通过websocket协议返回浏览器显示给用户，达到交互的目的。\n3. 问题解决以及服务端实现 在前两个步骤中，我已经通过分析把原理和难点梳理清楚了，目前就需要着手解决这些问题。\n3.1 如何获取 ssh code cf 有一个自带的命令 cf ssh-code 能够获取连接到容器用的 ssh code，但是我并没有在 cf 开源的 go 语言客户端 cfclient 中发现相关的 API，所以我去查看了 cf cli 的源码，并在里面发现了 cc 暴露出来的接口，有了这个接口之后，就能够通过 http 请求的方式获取 ssh-code。由于 cfclient 中并没有相关的代码，所以不得不自己实现一些方来获取 ssh-code, 于是这个问题解决了。\n3.2 如何将 websocket 和 ssh 这两个协议的消息进行转换 连接建立：\nfunc WS(c *gin.Context) { // 初始化websocket连接 upgrader := websocket.Upgrader{ ReadBufferSize: 1024, WriteBufferSize: 1024, } ws, err := upgrader.Upgrade(c.Writer, c.Request, nil) defer ws.Close() // 初始化ssh连接 cl, _ := c.Get(\u0026quot;claims\u0026quot;) s, _ := c.Get(\u0026quot;session\u0026quot;) claims := cl.(*utils.Claims) session := s.(*utils.Session) sshShell := utils.SSHShellSession{ Node: utils.Node{ Host: claims.Host, Port: claims.Port, }, } var wsBuff WebSocketBufferWriter sshShell.StdoutPipe = \u0026amp;wsBuff err = sshConn.Connect(username, password) defer sshConn.Close() defer wsBuff.Flush(websocket.TextMessage, ws) ...... ...... }  连接保持：\nfunc WS(c *gin.Context) { ...... ...... done := make(chan bool, 3) setDone := func() { done \u0026lt;- true } // 数据转换：websocket ----\u0026gt; SSH writeMessageToSSHServer := func(wc io.WriteCloser) { defer setDone() for { // 从websocket读取数据 msgType, p, err := ws.ReadMessage() if err = DispatchMessage(sshShell.Session, msgType, p, wc); err != nil { log.Println(\u0026quot;Error: error write data to ssh server:\u0026quot;, err) return } } } stopper := make(chan bool) // 数据转换：SSH ----\u0026gt; websocket writeBufferToWebSocket := func() { defer setDone() tick := time.NewTicker(time.Millisecond * time.Duration(utils.Config.SSH.BufferCheckerCycleTime)) defer tick.Stop() for { select { case \u0026lt;-tick.C: if err := wsBuff.Flush(websocket.TextMessage, ws); err != nil { log.Println(\u0026quot;Error: error sending data via webSocket:\u0026quot;, err) return } case \u0026lt;-stopper: return } } } go writeMessageToSSHServer(sshShell.StdinPipe) go writeBufferToWebSocket() go func() { defer setDone() if err := sshShell.Session.Wait(); err != nil{ log.Println(\u0026quot;ssh exist from server\u0026quot;, err) } }() \u0026lt;-done stopper \u0026lt;- true log.Println(\u0026quot;Info: websocket finished!\u0026quot;) }  控制访问权限：\n利用 cf 自带的权限认证机制实现。\n","id":2,"section":"posts","summary":"1. 调研 前端：了解到有一个非常优秀的开源web终端库： xterm.js , 使用起来也比较简单。 后端：使用 go 语言实现，因为 go 语言拥有许多优秀的开源ssh库，能够","tags":["ssh"],"title":"如何设计与实现WebCosole","uri":"https://wangzeping722.github.io/2019/12/how-to-write-webconsole/","year":"2019"}],"tags":[{"title":"coredns","uri":"https://wangzeping722.github.io/tags/coredns/"},{"title":"ssh","uri":"https://wangzeping722.github.io/tags/ssh/"}]}