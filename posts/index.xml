<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on 给我一条鱼🐟</title>
		<link>https://wangzeping722.github.io/posts/</link>
		<description>Recent content in Posts on 给我一条鱼🐟</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>zh</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Sun, 16 Aug 2020 11:58:45 +0800</lastBuildDate>
		<atom:link href="https://wangzeping722.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>TiDB学习课程 - week1</title>
			<link>https://wangzeping722.github.io/posts/tidb-hello-transaction-week1/</link>
			<pubDate>Sun, 16 Aug 2020 11:58:45 +0800</pubDate>
			
			<guid>https://wangzeping722.github.io/posts/tidb-hello-transaction-week1/</guid>
			<description>最近非常想学习关于分布式系统的知识，碰巧 TiDB 官方推出了《高性能 TiDB 系列课程》，我就像捡到宝一样高兴😄呀。希望能够通过这次的课程有所收获，我一定会</description>
			<content type="html"><![CDATA[<p>最近非常想学习关于分布式系统的知识，碰巧 TiDB 官方推出了《高性能 TiDB 系列课程》，我就像捡到宝一样高兴😄呀。希望能够通过这次的课程有所收获，我一定会坚持学完的。</p>
<h2 id="题目描述">题目描述</h2>
<p>本地下载 TiDB，TiKV，PD 源代码，改写源码并编译部署以下环境：</p>
<ul>
<li>1 TiDB</li>
<li>1 PD</li>
<li>3 TiKV </li>
</ul>
<p>改写后：使得 TiDB 启动事务时，能打印出一个 “hello transaction” 的 日志 。</p>
<h2 id="源码编译">源码编译</h2>
<p>我是在本地直接编译运行的，过程有些繁琐，当然也可以写一个 Dockerfile 来自动化部署啦。</p>
<p>这三个项目的编译都非常简单，先把项目分别拉下来，然后分别进入每个项目下执行 make 就可以编译成功。编译后二进制的路径如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">pd/bin/
tidb/bin/
tikv/target/debug/
</code></pre></div><h2 id="部署">部署</h2>
<p>参考 <a href="https://github.com/tikv/tikv/blob/master/docs/how-to/deploy/using-binary.md">TiKV</a> 集群的部署方案就可以把 <code>PD</code> 和 <code>TiKV</code> 这两个组件部署成功，然后再单独部署一个 <code>TiDB</code> 节点就完成了作业的部署要求：</p>
<ol>
<li>
<p>启动 PD</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">./pd-server --name<span class="o">=</span>pd1 <span class="se">\
</span><span class="se"></span>    --data-dir<span class="o">=</span>pd1 <span class="se">\
</span><span class="se"></span>    --client-urls<span class="o">=</span><span class="s2">&#34;http://127.0.0.1:2379&#34;</span> <span class="se">\
</span><span class="se"></span>    --peer-urls<span class="o">=</span><span class="s2">&#34;http://127.0.0.1:2380&#34;</span> <span class="se">\
</span><span class="se"></span>    --initial-cluster<span class="o">=</span><span class="s2">&#34;pd1=http://127.0.0.1:2380&#34;</span> <span class="se">\
</span><span class="se"></span>    --log-file<span class="o">=</span>pd1.log
</code></pre></div></li>
<li>
<p>启动 TiKV 集群：在部署 TiKV 的时候遇到一个小问题【单进程的最大文件描述符不满足 TiKV 的需求】，所以需要改一下系统配置（MacOS）</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">#修改文件描述符大小</span>
sudo launchctl limit maxfiles <span class="m">65536</span> <span class="m">200000</span>
   
./tikv-server --pd-endpoints<span class="o">=</span><span class="s2">&#34;127.0.0.1:2379&#34;</span> <span class="se">\
</span><span class="se"></span>    --addr<span class="o">=</span><span class="s2">&#34;127.0.0.1:20160&#34;</span> <span class="se">\
</span><span class="se"></span>    --data-dir<span class="o">=</span>tikv1 <span class="se">\
</span><span class="se"></span>    --log-file<span class="o">=</span>tikv1.log
   
./tikv-server --pd-endpoints<span class="o">=</span><span class="s2">&#34;127.0.0.1:2379&#34;</span> <span class="se">\
</span><span class="se"></span>    --addr<span class="o">=</span><span class="s2">&#34;127.0.0.1:20161&#34;</span> <span class="se">\
</span><span class="se"></span>    --data-dir<span class="o">=</span>tikv2 <span class="se">\
</span><span class="se"></span>    --log-file<span class="o">=</span>tikv2.log
   
./tikv-server --pd-endpoints<span class="o">=</span><span class="s2">&#34;127.0.0.1:2379&#34;</span> <span class="se">\
</span><span class="se"></span>    --addr<span class="o">=</span><span class="s2">&#34;127.0.0.1:20162&#34;</span> <span class="se">\
</span><span class="se"></span>    --data-dir<span class="o">=</span>tikv3 <span class="se">\
</span><span class="se"></span>    --log-file<span class="o">=</span>tikv3.log
</code></pre></div></li>
<li>
<p>启动 TiDB</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">./tidb-server --store<span class="o">=</span>tikv --path<span class="o">=</span><span class="s1">&#39;127.0.0.1:2379&#39;</span> --log-file<span class="o">=</span>tidb.log
</code></pre></div></li>
</ol>
<p>部署完之后，我们查看 tidb.log 这个日志，出现 <code>server is running MySQL protocol</code> 后，就是部署完成啦。</p>
<h3 id="修改源码">修改源码</h3>
<p>TiDB 的源码对新手来说算是非常友好的了，可以从<code>tidb-server</code>中的 main 函数开始一路追踪到连接建立和处理客户端请求的代码，简单易懂。下面给出流程，具体的以后找个时间分析分析：</p>
<p>直到遇到了<code>session.go</code>中的这段代码，加上日志就算大功告成啦。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// InitTxnWithStartTS create a transaction with startTS.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">session</span><span class="p">)</span> <span class="nf">InitTxnWithStartTS</span><span class="p">(</span><span class="nx">startTS</span> <span class="kt">uint64</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">txn</span><span class="p">.</span><span class="nf">Valid</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>

	<span class="c1">// no need to get txn from txnFutureCh since txn should init with startTs
</span><span class="c1"></span>  <span class="nx">logutil</span><span class="p">.</span><span class="nf">BgLogger</span><span class="p">(</span><span class="p">)</span><span class="p">.</span><span class="nf">Info</span><span class="p">(</span><span class="s">&#34;hello transaction&#34;</span><span class="p">)</span>
	<span class="nx">txn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">store</span><span class="p">.</span><span class="nf">BeginWithStartTS</span><span class="p">(</span><span class="nx">startTS</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="nx">txn</span><span class="p">.</span><span class="nf">SetVars</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">sessionVars</span><span class="p">.</span><span class="nx">KVVars</span><span class="p">)</span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">txn</span><span class="p">.</span><span class="nf">changeInvalidToValid</span><span class="p">(</span><span class="nx">txn</span><span class="p">)</span>
	<span class="nx">err</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">loadCommonGlobalVariablesIfNeeded</span><span class="p">(</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>重新编译运行 TiDB，你还会发现一个有意思的现象，那就是程序会狂打 <code>hello transaction</code>，这是因为 TiDB 后台会有一些定时任务在不断地开始事务执行一些操作。</p>
<p>到这里，week1 的的作用就算大功告成啦。希望自己能坚持下来💪~~~</p>
]]></content>
		</item>
		
		<item>
			<title>DNS学习总结</title>
			<link>https://wangzeping722.github.io/posts/dns-recording/</link>
			<pubDate>Mon, 23 Dec 2019 10:36:05 +0800</pubDate>
			
			<guid>https://wangzeping722.github.io/posts/dns-recording/</guid>
			<description>DNS 有多种记录类型，每种记录都有不同的作用，这篇文章主要总结了常用的记录。 A A（Address）记录用来指定主机名（域名）对应的 IPv4 地址记录。比</description>
			<content type="html"><![CDATA[<p>DNS 有多种记录类型，每种记录都有不同的作用，这篇文章主要总结了常用的记录。</p>
<h4 id="a">A</h4>
<p>A（Address）记录用来指定主机名（域名）对应的 IPv4 地址记录。比如，当你浏览一个网页时候会，浏览器就会先去查找对应域名的 A 记录，来获取 IP 地址，获得了 IP 地址，才能与服务器建立连接。</p>
<blockquote>
<p>我们可以为同一个域名添加多个 A 记录，解析的时候，会得到多个 IP，会随机选择一个使用。</p>
</blockquote>
<p><em>域名不区分大小写。记录的名称应该是由 ASCII 码字母、数字和 - 组成。</em></p>
<h4 id="aaaa">AAAA</h4>
<p>AAAA 记录用来指定主机名（域名）对应的 IPv6 地址记录，其他与 A 相同。</p>
<h4 id="cname-canonical-names">CNAME （canonical names）</h4>
<p>CNAME（规范名称），也就是别名记录，它能够让我们把多个名字映射到同一个主机。</p>
<p>应用场景：</p>
<ul>
<li>使用 CDN 服务时。</li>
<li>假如一个服务器运行着 100 个网站，这 100 个网站 CNAME 到 <code>a.example.com</code>。当该服务器 IP 改变时，你只需改变 <code>a.example.com</code>的 IP 就可以了。</li>
</ul>
<p>注意：由于<code>CNAME</code>记录就是一个替换，所以域名一旦设置<code>CNAME</code>记录以后，就不能再设置其他记录了（比如<code>A</code>记录和<code>MX</code>记录），这是为了防止产生冲突。举例来说，<code>foo.com</code>指向<code>bar.com</code>，而两个域名各有自己的<code>MX</code>记录，如果两者不一致，就会产生问题。由于顶级域名通常要设置<code>MX</code>记录，所以一般不允许用户对顶级域名设置<code>CNAME</code>记录。</p>
<p>A记录是把域名解析到IP地址，而CNAME记录是把域名解析到另外一个域名，而这个域名最终会指向A记录，在功能实现在上A记录与CNAME记录没有区别。</p>
<p>例如：</p>
<pre><code class="language-dns" data-lang="dns">a.example.com       IN      A       192.168.1.101
b.example.com       IN      CNAME   a.example.com（规范名称）
</code></pre><p>你在请求 b.example.com 的时候，他会先返回给你一个 CNAME ，然后你在用 CNAME 去查询。</p>
<h4 id="ns">NS</h4>
<p>NS（Name Server），域名服务器记录，返回保存下一级域名信息的服务器地址。该记录只能设置为域名，不能设置为IP地址。</p>
<p>一般来说，为了服务的安全可靠，至少应该有两条<code>NS</code>记录，而<code>A</code>记录和<code>MX</code>记录也可以有多条，这样就提供了服务的冗余性，防止出现单点失败。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ dig NS google.com
google.com.		777	IN	NS	ns4.google.com.
google.com.		777	IN	NS	ns3.google.com.
google.com.		777	IN	NS	ns2.google.com.
google.com.		777	IN	NS	ns1.google.com.
</code></pre></div><p>我们可以看见，google 的权威 NS 服务器有四个。</p>
<h4 id="mx">MX</h4>
<p>MX（MX record），邮件交换记录，用于邮件服务器的地址。MX 记录允许设置优先级，当多个邮件服务器可用时，会根据该值决定投递邮件的服务器（值小的优先），下面的<code>20, 10, 40 ...</code>就表示优先级。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ dig MX google.com
google.com.		306	IN	MX	<span class="m">20</span> alt1.aspmx.l.google.com.
google.com.		306	IN	MX	<span class="m">10</span> aspmx.l.google.com.
google.com.		306	IN	MX	<span class="m">40</span> alt3.aspmx.l.google.com.
google.com.		306	IN	MX	<span class="m">30</span> alt2.aspmx.l.google.com.
google.com.		306	IN	MX	<span class="m">50</span> alt4.aspmx.l.google.com.
</code></pre></div><h4 id="soa">SOA</h4>
<p>SOA 叫做起始授权机构记录，NS用于标识多台域名解析服务器，SOA记录用于在众多NS记录中的<strong>主服务器</strong>。SOA 记录表示此域名的权威解析服务器地址。 当要查询的域名在所有递归解析服务器中没有域名解析的缓存时，就会回源来请求此域名的SOA记录，也叫权威解析记录。</p>
<p>没有SOA记录的 zone 不符合 RFC 1035 要求的标准。</p>
<pre><code>$TTL 86400
@   IN  SOA     startech60serve root.startech60serve.com. (
        2018110201  ;Serial
        3600        ;Refresh
        1800        ;Retry
        604800      ;Expire
        86400       ;Minimum TTL
)
        IN  NS      startech60serve
        IN  A       192.168.1.3
        IN  MX 10   startech60serve
startech60serve     IN  A       192.168.1.3
</code></pre><p><code>root.startech60serve.com. </code>其中第一个点表示是@</p>
<h4 id="txt">TXT</h4>
<p>TXT（TXT record），文本记录，一般用来描述一个域名，或者用来做某种验证功能，例如：</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ dig TXT google.com
google.com.		300	IN	TXT	<span class="s2">&#34;docusign=05958488-4752-4ef2-95eb-aa7ba8a3bd0e&#34;</span>
google.com.		3600	IN	TXT	<span class="s2">&#34;facebook-domain-verification=22rm551cu4k0ab0bxsw536tlds4h95&#34;</span>
google.com.		300	IN	TXT	<span class="s2">&#34;docusign=1b0a6754-49b1-4db5-8540-d2c12664b289&#34;</span>
google.com.		3600	IN	TXT	<span class="s2">&#34;globalsign-smime-dv=CDYX+XFHUw2wml6/Gb8+59BsH31KzUr6c1l2BPvqKX8=&#34;</span>
google.com.		3600	IN	TXT	<span class="s2">&#34;v=spf1 include:_spf.google.com ~all&#34;</span>
</code></pre></div><h4 id="ptr">PTR</h4>
<p>PTR 记录是 A 记录的逆向记录，又称做 IP 反查记录或指针记录，负责将 IP 反向解析为域名，即反向域名解析。</p>
<p>参考：</p>
<p><a href="https://skyao.io/learning-dns/dns/">https://skyao.io/learning-dns/dns/</a></p>
<p><a href="https://deepzz.com/post/dns-recording-type.html">https://deepzz.com/post/dns-recording-type.html</a></p>
]]></content>
		</item>
		
		<item>
			<title>如何设计与实现 WebConsole</title>
			<link>https://wangzeping722.github.io/posts/how-to-write-webconsole/</link>
			<pubDate>Wed, 04 Dec 2019 09:13:51 +0800</pubDate>
			
			<guid>https://wangzeping722.github.io/posts/how-to-write-webconsole/</guid>
			<description>1. 调研 前端：了解到有一个非常优秀的开源web终端库： xterm.js , 使用起来也比较简单。 后端：使用 go 语言实现，因为 go 语言拥有许多优秀的开源ssh库，能够</description>
			<content type="html"><![CDATA[<h3 id="1-调研">1. 调研</h3>
<p>前端：了解到有一个非常优秀的开源web终端库： <strong>xterm.js</strong> , 使用起来也比较简单。</p>
<p>后端：使用 go 语言实现，因为 go 语言拥有许多优秀的开源ssh库，能够满足我们的需求。</p>
<p>难点：</p>
<pre><code>1. 如何与 cf(cloud foundry) 进行交互得到 `ssh code` ？
2. 如何把 ssh 命令行转换成 websocket 通讯, 并输出到 xterm.js 中？
3. 如何控制访问权限？
</code></pre>
<h3 id="2-原理">2. 原理</h3>
<p><img src="webconsole1.png" alt="webconsole原理图"></p>
<p>​	1. 浏览器向服务器发起 websocket 请求</p>
<p>​	2. 服务器通过 ssh 连接到 cf 容器</p>
<p>​	3. 连接建立，服务器负责转发消息</p>
<p>在后端和浏览器之间建立websocket连接后，将用户在浏览器中输入的命令通过 websocket 协议发送到后端，后端使用 ssh 协议将命令输入到容器ssh进程的 stdin，命令执行后，再从 stdout 中读取输出，通过websocket协议返回浏览器显示给用户，达到交互的目的。</p>
<h3 id="3-问题解决以及服务端实现">3. 问题解决以及服务端实现</h3>
<p>在前两个步骤中，我已经通过分析把原理和难点梳理清楚了，目前就需要着手解决这些问题。</p>
<h4 id="31-如何获取-ssh-code">3.1 如何获取 ssh code</h4>
<p>cf 有一个自带的命令 <code>cf ssh-code</code> 能够获取连接到容器用的 <code>ssh code</code>，但是我并没有在 cf 开源的 go 语言客户端 <code>cfclient</code> 中发现相关的 API，所以我去查看了 cf cli 的源码，并在里面发现了 <strong>cc</strong> 暴露出来的接口，有了这个接口之后，就能够通过 http 请求的方式获取 <code>ssh-code</code>。由于 <code>cfclient</code> 中并没有相关的代码，所以不得不自己实现一些方来获取 <code>ssh-code</code>, 于是这个问题解决了。</p>
<h4 id="32-如何将-websocket-和-ssh-这两个协议的消息进行转换">3.2 如何将 websocket 和 ssh 这两个协议的消息进行转换</h4>
<p><strong>连接建立</strong>：</p>
<p><img src="webconsole2.png" alt=""></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">WS</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 初始化websocket连接
</span><span class="c1"></span>	<span class="nx">upgrader</span> <span class="o">:=</span> <span class="nx">websocket</span><span class="p">.</span><span class="nx">Upgrader</span><span class="p">{</span>
		<span class="nx">ReadBufferSize</span><span class="p">:</span>  <span class="mi">1024</span><span class="p">,</span>
		<span class="nx">WriteBufferSize</span><span class="p">:</span> <span class="mi">1024</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="nx">ws</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">upgrader</span><span class="p">.</span><span class="nf">Upgrade</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="k">defer</span> <span class="nx">ws</span><span class="p">.</span><span class="nf">Close</span><span class="p">(</span><span class="p">)</span>
  
	<span class="c1">// 初始化ssh连接
</span><span class="c1"></span>	<span class="nx">cl</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;claims&#34;</span><span class="p">)</span>
	<span class="nx">s</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;session&#34;</span><span class="p">)</span>
	<span class="nx">claims</span> <span class="o">:=</span> <span class="nx">cl</span><span class="p">.</span><span class="p">(</span><span class="o">*</span><span class="nx">utils</span><span class="p">.</span><span class="nx">Claims</span><span class="p">)</span>
	<span class="nx">session</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="p">(</span><span class="o">*</span><span class="nx">utils</span><span class="p">.</span><span class="nx">Session</span><span class="p">)</span>

	<span class="nx">sshShell</span> <span class="o">:=</span> <span class="nx">utils</span><span class="p">.</span><span class="nx">SSHShellSession</span><span class="p">{</span>
		<span class="nx">Node</span><span class="p">:</span> <span class="nx">utils</span><span class="p">.</span><span class="nx">Node</span><span class="p">{</span>
			<span class="nx">Host</span><span class="p">:</span> <span class="nx">claims</span><span class="p">.</span><span class="nx">Host</span><span class="p">,</span>
			<span class="nx">Port</span><span class="p">:</span> <span class="nx">claims</span><span class="p">.</span><span class="nx">Port</span><span class="p">,</span>
		<span class="p">}</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">wsBuff</span> <span class="nx">WebSocketBufferWriter</span>
	<span class="nx">sshShell</span><span class="p">.</span><span class="nx">StdoutPipe</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">wsBuff</span>
	<span class="nx">err</span> <span class="p">=</span> <span class="nx">sshConn</span><span class="p">.</span><span class="nf">Connect</span><span class="p">(</span><span class="nx">username</span><span class="p">,</span> <span class="nx">password</span><span class="p">)</span>
	<span class="k">defer</span> <span class="nx">sshConn</span><span class="p">.</span><span class="nf">Close</span><span class="p">(</span><span class="p">)</span>
	<span class="k">defer</span> <span class="nx">wsBuff</span><span class="p">.</span><span class="nf">Flush</span><span class="p">(</span><span class="nx">websocket</span><span class="p">.</span><span class="nx">TextMessage</span><span class="p">,</span> <span class="nx">ws</span><span class="p">)</span>
	<span class="o">...</span><span class="o">...</span>
  <span class="o">...</span><span class="o">...</span>
<span class="p">}</span>
</code></pre></div><p><strong>连接保持：</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">WS</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">...</span><span class="o">...</span>
  <span class="o">...</span><span class="o">...</span>
	<span class="nx">done</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
	<span class="nx">setDone</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span> <span class="nx">done</span> <span class="o">&lt;-</span> <span class="kc">true</span> <span class="p">}</span>

	<span class="c1">// 数据转换：websocket ----&gt; SSH
</span><span class="c1"></span>	<span class="nx">writeMessageToSSHServer</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">wc</span> <span class="nx">io</span><span class="p">.</span><span class="nx">WriteCloser</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="nf">setDone</span><span class="p">(</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">{</span>
			<span class="c1">// 从websocket读取数据
</span><span class="c1"></span>			<span class="nx">msgType</span><span class="p">,</span> <span class="nx">p</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ws</span><span class="p">.</span><span class="nf">ReadMessage</span><span class="p">(</span><span class="p">)</span>

			<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">DispatchMessage</span><span class="p">(</span><span class="nx">sshShell</span><span class="p">.</span><span class="nx">Session</span><span class="p">,</span> <span class="nx">msgType</span><span class="p">,</span> <span class="nx">p</span><span class="p">,</span> <span class="nx">wc</span><span class="p">)</span><span class="p">;</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Error: error write data to ssh server:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
				<span class="k">return</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nx">stopper</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">)</span>
	<span class="c1">// 数据转换：SSH ----&gt; websocket
</span><span class="c1"></span>	<span class="nx">writeBufferToWebSocket</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="nf">setDone</span><span class="p">(</span><span class="p">)</span>
		<span class="nx">tick</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTicker</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="nx">utils</span><span class="p">.</span><span class="nx">Config</span><span class="p">.</span><span class="nx">SSH</span><span class="p">.</span><span class="nx">BufferCheckerCycleTime</span><span class="p">)</span><span class="p">)</span>
		<span class="k">defer</span> <span class="nx">tick</span><span class="p">.</span><span class="nf">Stop</span><span class="p">(</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">{</span>
			<span class="k">select</span> <span class="p">{</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">tick</span><span class="p">.</span><span class="nx">C</span><span class="p">:</span>
				<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">wsBuff</span><span class="p">.</span><span class="nf">Flush</span><span class="p">(</span><span class="nx">websocket</span><span class="p">.</span><span class="nx">TextMessage</span><span class="p">,</span> <span class="nx">ws</span><span class="p">)</span><span class="p">;</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Error: error sending data via webSocket:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
					<span class="k">return</span>
				<span class="p">}</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">stopper</span><span class="p">:</span>
				<span class="k">return</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">go</span> <span class="nf">writeMessageToSSHServer</span><span class="p">(</span><span class="nx">sshShell</span><span class="p">.</span><span class="nx">StdinPipe</span><span class="p">)</span>
	<span class="k">go</span> <span class="nf">writeBufferToWebSocket</span><span class="p">(</span><span class="p">)</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="nf">setDone</span><span class="p">(</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">sshShell</span><span class="p">.</span><span class="nx">Session</span><span class="p">.</span><span class="nf">Wait</span><span class="p">(</span><span class="p">)</span><span class="p">;</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">{</span>
			<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;ssh exist from server&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span><span class="p">(</span><span class="p">)</span>

	<span class="o">&lt;-</span><span class="nx">done</span>
	<span class="nx">stopper</span> <span class="o">&lt;-</span> <span class="kc">true</span> 
	<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Info: websocket finished!&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p><strong>控制访问权限</strong>：</p>
<p>利用 cf 自带的权限认证机制实现。</p>
]]></content>
		</item>
		
	</channel>
</rss>
