<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on 给我一条鱼🐟</title>
		<link>https://wangzeping722.github.io/posts/</link>
		<description>Recent content in Posts on 给我一条鱼🐟</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>zh</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Tue, 29 Jun 2021 10:42:41 +0800</lastBuildDate>
		<atom:link href="https://wangzeping722.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>Raft Lab 2a</title>
			<link>https://wangzeping722.github.io/posts/raft-lab-2a/</link>
			<pubDate>Tue, 29 Jun 2021 10:42:41 +0800</pubDate>
			
			<guid>https://wangzeping722.github.io/posts/raft-lab-2a/</guid>
			<description>Raft实验基于2021的代码。 lab2a 是的目的就是选主，首先需要明确，不使用timer或者ticker，而是使用sleep，这也是实验要求。 代码</description>
			<content type="html"><![CDATA[<p>Raft实验基于2021的代码。</p>
<p>lab2a 是的目的就是选主，首先需要明确，不使用timer或者ticker，而是使用sleep，这也是实验要求。</p>
<p>代码库已经给我们搭建好了基础框架，我们只需要按照论文的要求来设计和填入代码就能够完成实验，lab2a的大致思路就是：raft协议中的leader定期向follower发送心跳，接受到心跳的follower要及时应答，如果follower没有及时接收到心跳，那么就会触发选主。</p>
<h3 id="raft结构体">Raft结构体</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Raft</span> <span class="kd">struct</span> <span class="p">{</span>
   <span class="nx">mu</span>        <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>          <span class="c1">// Lock to protect shared access to this peer&#39;s state
</span><span class="c1"></span>   <span class="nx">peers</span>     <span class="p">[]</span><span class="o">*</span><span class="nx">labrpc</span><span class="p">.</span><span class="nx">ClientEnd</span> <span class="c1">// RPC end points of all peers
</span><span class="c1"></span>   <span class="nx">persister</span> <span class="o">*</span><span class="nx">Persister</span>          <span class="c1">// Object to hold this peer&#39;s persisted state
</span><span class="c1"></span>   <span class="nx">me</span>        <span class="kt">int</span>                 <span class="c1">// this peer&#39;s index into peers[]
</span><span class="c1"></span>   <span class="nx">dead</span>      <span class="kt">int32</span>               <span class="c1">// set by Kill()
</span><span class="c1"></span>
   <span class="c1">// Your data here (2A, 2B, 2C).
</span><span class="c1"></span>   <span class="c1">// Look at the paper&#39;s Figure 2 for a description of what
</span><span class="c1"></span>   <span class="c1">// state a Raft server must maintain.
</span><span class="c1"></span>
   <span class="c1">// 2A leader election and heartbeat
</span><span class="c1"></span>   <span class="nx">currentTerm</span>       <span class="kt">int</span>       <span class="c1">// 当前任期
</span><span class="c1"></span>   <span class="nx">state</span>             <span class="nx">State</span>     <span class="c1">// 节点状态
</span><span class="c1"></span>   <span class="nx">votedFor</span>          <span class="kt">int</span>       <span class="c1">// 投票
</span><span class="c1"></span>   <span class="nx">lastHeartBeatTime</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span> <span class="c1">// 上次心跳的时间
</span><span class="c1"></span>   <span class="nx">heartBeatChan</span>     <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span> <span class="c1">// 通知接收到心跳的chan
</span><span class="c1"></span>   <span class="c1">//TODO 2B and 2C
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>Raft 结构体保存了当前节点的状态，已经其他节点的信息。</p>
<p>所以，在Make函数中，我们要返回代表当前节点的raft对象：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Make</span><span class="p">(</span><span class="nx">peers</span> <span class="p">[]</span><span class="o">*</span><span class="nx">labrpc</span><span class="p">.</span><span class="nx">ClientEnd</span><span class="p">,</span> <span class="nx">me</span> <span class="kt">int</span><span class="p">,</span>
	<span class="nx">persister</span> <span class="o">*</span><span class="nx">Persister</span><span class="p">,</span> <span class="nx">applyCh</span> <span class="kd">chan</span> <span class="nx">ApplyMsg</span><span class="p">)</span> <span class="o">*</span><span class="nx">Raft</span> <span class="p">{</span>
	<span class="nx">rf</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Raft</span><span class="p">{}</span>
	<span class="nx">rf</span><span class="p">.</span><span class="nx">peers</span> <span class="p">=</span> <span class="nx">peers</span>
	<span class="nx">rf</span><span class="p">.</span><span class="nx">persister</span> <span class="p">=</span> <span class="nx">persister</span>
	<span class="nx">rf</span><span class="p">.</span><span class="nx">me</span> <span class="p">=</span> <span class="nx">me</span>

	<span class="c1">// Your initialization code here (2A, 2B, 2C).
</span><span class="c1"></span>	<span class="nx">rf</span><span class="p">.</span><span class="nx">state</span> <span class="p">=</span> <span class="nx">Follower</span>
	<span class="nx">rf</span><span class="p">.</span><span class="nx">votedFor</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
	<span class="nx">rf</span><span class="p">.</span><span class="nx">currentTerm</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">rf</span><span class="p">.</span><span class="nx">heartBeatChan</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>

	<span class="c1">// initialize from state persisted before a crash
</span><span class="c1"></span>	<span class="nx">rf</span><span class="p">.</span><span class="nf">readPersist</span><span class="p">(</span><span class="nx">persister</span><span class="p">.</span><span class="nf">ReadRaftState</span><span class="p">())</span>

	<span class="c1">// start ticker goroutine to start elections
</span><span class="c1"></span>	<span class="k">go</span> <span class="nx">rf</span><span class="p">.</span><span class="nf">electTicker</span><span class="p">()</span>
	<span class="k">go</span> <span class="nx">rf</span><span class="p">.</span><span class="nf">heartBeatTicker</span><span class="p">()</span>

	<span class="k">return</span> <span class="nx">rf</span>
<span class="p">}</span>
</code></pre></div><p>可以看到，Make函数做了一些列的初始化操作，并开启了两个后台运行的协程。</p>
<h3 id="electticker">electTicker</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">rf</span> <span class="o">*</span><span class="nx">Raft</span><span class="p">)</span> <span class="nf">electTicker</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">rf</span><span class="p">.</span><span class="nf">killed</span><span class="p">()</span> <span class="o">==</span> <span class="kc">false</span> <span class="p">{</span>
		<span class="c1">// 获取随机的选举超时时间
</span><span class="c1"></span>		<span class="nx">electTimeout</span> <span class="o">:=</span> <span class="nf">getElectTimeout</span><span class="p">()</span>
		<span class="c1">// 使用time.Sleep来控制，而不是使用timer，使用timer在系统负载增加的时候可能会延迟。
</span><span class="c1"></span>		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">electTimeout</span><span class="p">)</span>

		<span class="k">if</span> <span class="nx">rf</span><span class="p">.</span><span class="nf">getState</span><span class="p">()</span> <span class="o">==</span> <span class="nx">Leader</span> <span class="p">{</span>
			<span class="k">continue</span>
		<span class="p">}</span>

		<span class="nx">duration</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Since</span><span class="p">(</span><span class="nx">rf</span><span class="p">.</span><span class="nf">getHeartbeatTime</span><span class="p">())</span>
		<span class="k">if</span> <span class="nx">duration</span> <span class="p">&gt;</span> <span class="nx">electTimeout</span> <span class="p">{</span>
			<span class="c1">// 没有收到心跳，发起超时选举
</span><span class="c1"></span>			<span class="k">go</span> <span class="nx">rf</span><span class="p">.</span><span class="nf">election</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>electTicker 方法实现了超时选举，需要注意的是 <code>getElectTimeout()</code> 获取的是一个随机的超时时间。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">getElectTimeout</span><span class="p">()</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span> <span class="p">{</span>
	<span class="nx">ms</span> <span class="o">:=</span> <span class="mi">300</span> <span class="o">+</span> <span class="nx">rand</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="mi">240</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="nx">ms</span><span class="p">)</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span>
<span class="p">}</span>
</code></pre></div><h3 id="heartbeatticker">heartBeatTicker</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">rf</span> <span class="o">*</span><span class="nx">Raft</span><span class="p">)</span> <span class="nf">heartBeatTicker</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">rf</span><span class="p">.</span><span class="nf">killed</span><span class="p">()</span> <span class="o">==</span> <span class="kc">false</span> <span class="p">{</span>
		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">heartBeatInterval</span><span class="p">)</span>
	  <span class="c1">// 不是leader， 不能发送心跳
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">rf</span><span class="p">.</span><span class="nf">getState</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">Leader</span> <span class="p">{</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">peers</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">me</span> <span class="o">==</span> <span class="nx">i</span> <span class="p">{</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="c1">//DPrintf(&#34;[server-%d] heartBeatTicker to peer[%d]\n&#34;, rf.me, i)
</span><span class="c1"></span>			<span class="k">go</span> <span class="nx">rf</span><span class="p">.</span><span class="nf">sendHeartBeat</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>以上两个函数就是实现超时选举的关键，其他rpc请求只需要按照论文所要求的的翻译出来即可。</p>
<h3 id="如何赢得选票">如何赢得选票？</h3>
<p>在candidate进行选举的时候，会向所有的peer发送<code>RequestVote</code> 这个PRC请求，如果收到的投票大于等于<code>len(rf.peers)/2 + 1</code>  , 也就是一半以上，那么candidate就会变成leader。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 发送请求
</span><span class="c1"></span><span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">peers</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">i</span> <span class="o">==</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">me</span> <span class="p">{</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="nx">reply</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">RequestVoteReply</span><span class="p">{}</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">server</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">!</span><span class="nx">rf</span><span class="p">.</span><span class="nf">sendRequestVote</span><span class="p">(</span><span class="nx">server</span><span class="p">,</span> <span class="nx">args</span><span class="p">,</span> <span class="nx">reply</span><span class="p">)</span> <span class="p">{</span>
				<span class="c1">//DPrintf(&#34;[server-%d] sendRequestVote failed rpc to peer[%d]\n&#34;, rf.me, server)
</span><span class="c1"></span>				<span class="nx">notifyChan</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span>
				<span class="k">return</span>
			<span class="p">}</span>
			<span class="nx">rf</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
			<span class="k">defer</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

			<span class="k">if</span> <span class="nx">startTerm</span> <span class="o">!=</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">currentTerm</span> <span class="p">{</span>
				<span class="k">return</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">Term</span> <span class="p">&gt;</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">currentTerm</span> <span class="p">{</span>
				<span class="nx">rf</span><span class="p">.</span><span class="nf">becomeFollower</span><span class="p">(</span><span class="nx">reply</span><span class="p">.</span><span class="nx">Term</span><span class="p">)</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">VoteGranted</span> <span class="p">{</span>
				<span class="nx">grantVoteCount</span><span class="o">++</span>
			<span class="p">}</span>
			<span class="nx">notifyChan</span> <span class="o">&lt;-</span> <span class="kd">struct</span><span class="p">{}{}</span>
		<span class="p">}(</span><span class="nx">i</span><span class="p">)</span>
	<span class="p">}</span>
	
	<span class="c1">// for循环获取结果，并添加超时处理
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">notifyChan</span><span class="p">:</span>
			<span class="nx">rf</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
			<span class="k">if</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">currentTerm</span> <span class="o">!=</span> <span class="nx">startTerm</span> <span class="p">{</span>
				<span class="nx">rf</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
				<span class="k">return</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">state</span> <span class="o">!=</span> <span class="nx">Candidate</span> <span class="p">{</span>
				<span class="nx">rf</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
				<span class="k">return</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="nx">grantVoteCount</span> <span class="o">&gt;=</span> <span class="nx">rf</span><span class="p">.</span><span class="nf">getMajority</span><span class="p">()</span> <span class="p">{</span>
				<span class="nx">rf</span><span class="p">.</span><span class="nf">becomeLeader</span><span class="p">()</span>
				<span class="nx">rf</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
				<span class="k">return</span>
			<span class="p">}</span>

			<span class="nx">rf</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">time</span><span class="p">.</span><span class="nf">After</span><span class="p">(</span><span class="nf">getElectTimeout</span><span class="p">()):</span>
			<span class="c1">// 退出
</span><span class="c1"></span>			<span class="nf">DPrintf</span><span class="p">(</span><span class="s">&#34;[server-%d] elect timeout, state[%d]\n&#34;</span><span class="p">,</span> <span class="nx">rf</span><span class="p">.</span><span class="nx">me</span><span class="p">,</span> <span class="nx">rf</span><span class="p">.</span><span class="nf">getState</span><span class="p">())</span>
			<span class="k">return</span>
		<span class="p">}</span>
	<span class="p">}</span>
</code></pre></div><p>lab2a的实现还是很简单的，但是在选举超时处理，和心跳方面需要下点功夫，不然三个测试会过不了哦。</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="err">➜</span>  <span class="nx">raft</span> <span class="nx">git</span><span class="p">:(</span><span class="nx">feat</span><span class="o">/</span><span class="nx">raft_2a</span><span class="p">)</span> <span class="err">✗</span> <span class="k">go</span> <span class="nx">test</span> <span class="o">-</span><span class="nx">run</span> <span class="mi">2</span><span class="nx">A</span> <span class="o">-</span><span class="nx">race</span>
<span class="nf">Test</span> <span class="p">(</span><span class="mi">2</span><span class="nx">A</span><span class="p">):</span> <span class="nx">initial</span> <span class="nx">election</span> <span class="o">...</span>
  <span class="o">...</span> <span class="nx">Passed</span> <span class="o">--</span>   <span class="mf">3.0</span>  <span class="mi">3</span>   <span class="mi">46</span>    <span class="mi">6142</span>    <span class="mi">0</span>
<span class="nf">Test</span> <span class="p">(</span><span class="mi">2</span><span class="nx">A</span><span class="p">):</span> <span class="nx">election</span> <span class="nx">after</span> <span class="nx">network</span> <span class="nx">failure</span> <span class="o">...</span>
  <span class="o">...</span> <span class="nx">Passed</span> <span class="o">--</span>   <span class="mf">4.5</span>  <span class="mi">3</span>   <span class="mi">96</span>    <span class="mi">8501</span>    <span class="mi">0</span>
<span class="nf">Test</span> <span class="p">(</span><span class="mi">2</span><span class="nx">A</span><span class="p">):</span> <span class="nx">multiple</span> <span class="nx">elections</span> <span class="o">...</span>
  <span class="o">...</span> <span class="nx">Passed</span> <span class="o">--</span>   <span class="mf">5.5</span>  <span class="mi">7</span>  <span class="mi">480</span>   <span class="mi">42904</span>    <span class="mi">0</span>
<span class="nx">PASS</span>
<span class="nx">ok</span>      <span class="mf">6.824</span><span class="o">/</span><span class="nx">raft</span>      <span class="mf">13.397</span><span class="nx">s</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>Raft 学习笔记</title>
			<link>https://wangzeping722.github.io/posts/raft/</link>
			<pubDate>Sun, 27 Jun 2021 23:12:50 +0800</pubDate>
			
			<guid>https://wangzeping722.github.io/posts/raft/</guid>
			<description>1. Raft 简介 Raft 是近年来非常受欢迎的共识算法，其目的就是为了在多个节点达成共识，允许一组机器像一个整体一样工作，即使一些机器出现故障、网络出现分区</description>
			<content type="html"><![CDATA[<h1 id="1-raft-简介">1. Raft 简介</h1>
<p>Raft 是近年来非常受欢迎的共识算法，其目的就是为了在多个节点达成共识，允许一组机器像一个整体一样工作，即使一些机器出现故障、网络出现分区也能继续工作下去。这使得 Raft 在构建可靠的大型软件系统中起着关键作用。</p>
<p>相比于其他共识算法，Raft 有以下特点：</p>
<ul>
<li>Strong leader：Raft 的日志只能由 leader 复制给其他 follower</li>
<li>Leader election：Raft 使用随机的超时时间进行 Leader 选择</li>
<li>Membership changes：Raft 改变集群中的服务器集的机制使用了一种新的联合共识方法，在这种方法中，<strong>两个不同的配置的多数会在过渡期间重叠</strong>。这使得集群在改变配置时能够继续正常运行。</li>
</ul>
<p>Raft 假设：</p>
<ul>
<li>服务器可能会宕机、会停止运行过段时间再恢复，但是<strong>非拜占庭的</strong>（即它的行为是非恶意的，不会篡改数据等）；</li>
<li>网络通信会中断，消息可能会丢失、延迟或乱序；可能会网络分区；</li>
</ul>
<p>我们将从 6 个部分解释 Raft：</p>
<ol>
<li>Leader 选举；</li>
<li>日志复制；</li>
<li>安全性；</li>
<li>配置变更：如何在集群中增加或删除节点；</li>
</ol>
<h1 id="2-复制状态机">2. 复制状态机</h1>
<p>一致性算法是在复制状态机的背景下提出的。在这种方法中，一组服务器上的状态机产生相同状态的副本，并且在一些机器宕机的情况下也能够继续运行。复制状态机本广泛的运用在分布式系统中，用来解决很多容错的问题。</p>
<p><img src="https://blog-wero.oss-cn-shanghai.aliyuncs.com/img/raft-%E5%9B%BE1.png" alt="https://blog-wero.oss-cn-shanghai.aliyuncs.com/img/raft-%E5%9B%BE1.png"></p>
<p>图1 复制状态机的结构。一致性算法管理着来自客户端指令的复制日志。状态机从日志中处理相同顺序的相同指令，所以产生的结果也是相同的。</p>
<p>复制状态机通常都是基于<strong>复制日志</strong>实现的。如图1，每一个服务器存储一个包含一系列指令的日志，并且按照日志的顺序进行执行。每一个日志都按照相同的顺序包含相同的指令，所以每一个服务器都执行相同的指令序列。因为每个状态机都是确定的，每一次执行操作都产生相同的状态和同样的序列。</p>
<h1 id="3-相关术语">3. 相关术语</h1>
<h2 id="服务器状态"><strong>服务器状态</strong></h2>
<p>服务器在任意时间只能处于以下三种状态之一，在正常操作中，只有一个 Leader，其他所有的服务器都是 Follower：</p>
<ul>
<li>Leader：处理所有客户端请求、日志复制。同一时刻最多只能有一个可行的 Leader；</li>
<li>Follower：完全被动的（不发送 RPC，只响应收到的 RPC）——大多数服务器在大多数情况下处于此状态；</li>
<li>Candidate：用来选举新的 Leader，处于 Leader 和 Follower 之间的暂时状态；</li>
</ul>
<p><img src="https://blog-wero.oss-cn-shanghai.aliyuncs.com/img/raft-server-state.png" alt=""></p>
<h2 id="任期">任期</h2>
<p>Raft 把时间分为任意长度的一个个的任期（<code>Term</code>），任期用连续的整数来编号。每个任期都是以 Candidate 发起选举操作开始的，每个任期只能有一位或者没有 Leader 诞生。</p>
<p>一个正常的任期至多有一个 Leader，通常分为两部分：</p>
<ul>
<li>任期开始时的选举过程；</li>
<li>正常运行的部分；</li>
</ul>
<p>有些任期可能没有选出 Leader，这时候 Candidate 会立即进入下一个任期，再次尝试选出一个 Leader。</p>
<p><img src="https://blog-wero.oss-cn-shanghai.aliyuncs.com/img/raft-term.png" alt=""></p>
<p>每个节点维护一个 currentTerm 变量，表示系统中当前任期。currentTerm 必须持久化存储，以便在服务器宕机重启时将其恢复。</p>
<h3 id="rpc"><strong>RPC</strong></h3>
<p>Raft 服务器的通信通过两个 RPC 调用：</p>
<ul>
<li><code>RequestVote</code>：用于选举；</li>
<li><code>AppendEntries</code>：用于复制 log 和发送心跳；</li>
</ul>
<h1 id="4-leader-选举">4. Leader 选举</h1>
<p>Raft 使用心跳机制来触发 Leader 选举。</p>
<ol>
<li>当服务器启动的时候，都是 Follower 状态，只要 Follower 能够在计时器超时前接收到 Candidate 或者 Leader 的 RPC 调用，那么就会保持 Follower 状态；</li>
<li>Leader 周期性的发送心跳给所有的 Follower来 maintain their authority；</li>
<li>在计时器超时后，Follower 会变成 Candidate，并且发起新一轮的选举；</li>
</ol>
<h2 id="选举过程">选举过程</h2>
<p>选举从 Follower 的计时器超时开始：</p>
<ol>
<li>Follower 自增 <code>currentTime</code> ，并且变为 Candidate 状态；</li>
<li>Candidate 给自己投票，设置 <code>voteFor</code> 为自己，并且并行的给其他服务器发起 <code>RequestVote</code> RPC请求；</li>
<li>Candidate 会保持当前状态，等待响应，直到以下三种情况发生：
<ul>
<li>赢得选举，变了 Leader</li>
<li>集群中已经有了 Leader，变为 Follower</li>
<li>选票被瓜分，currentTerm++，发起新一轮选举</li>
</ul>
</li>
</ol>
<p>下面分别讨论这三种情况：</p>
<h3 id="赢得选举">赢得选举</h3>
<p>如果 Candidate 从大多数服务器中获得当前任期的投票，那么 Candidate 赢得了选举，变为 Leader。然后它向所有服务器发送心跳来建立权威，也能够阻止新一轮的选举。</p>
<p>为了保证选举的安全性，选举需要遵循以下规则：</p>
<ul>
<li>每台服务器在给定的 Term 内最多只能为一名 Candidate 投票，以先到先得的方式进行；</li>
<li>只有获得超过半数节点的选票才能成为 Leader，少数服从多数的原则确保最多只有一名 Candidate 能在某一 Term 内赢得选举；</li>
</ul>
<h3 id="回退到-follower">回退到 Follower</h3>
<p>在等待投票期间，Candidate 有可能收到其他服务器的声明自己是 Leader 的 <code>AppendEntries</code> RPC 请求。如果 Leader 的 Term 大于等于 currentTerm，那么 Candidate 回退到 Follower 状态；反之，Candidate 会拒绝当前 RCP。</p>
<h3 id="保持-candidate-状态">保持 Candidate 状态</h3>
<p>第三个可能的结果是，一个 Candidate 既没有赢得选举，也没有输掉选举：如果许多 Follower 同时成为 Candidate，票数可能被瓜分，因此没有候选人获得多数。当这种情况发生时，每个候选人都会超时，并通过增加其 Term 和启动新一轮的 <code>RequestVote</code> RPC 来开始新的选举。然而，<strong>如果没有额外的措施，瓜分的投票可能会无限地重复。</strong></p>
<p>Raft 使用随机的选举超时时间来确保极少出现选票瓜分，以及出现之后也能够很快的被解决掉。为了防止一开始就出现分裂投票，选举超时是从一个固定的时间间隔中随机选择的（例如，150-300ms）。</p>
<h1 id="5-日志复制">5. 日志复制</h1>
<p>Leader 确认之后，就会开始接受客户端的请求。当 Leader 接收到客户端的请求之后，会把追加一条新日志，并且通过 <code>AppendEntries</code> RPC 把日志复制给其它服务器。</p>
<h2 id="日志的组织方式">日志的组织方式</h2>
<p><img src="https://blog-wero.oss-cn-shanghai.aliyuncs.com/img/raft-log-structure.png" alt=""></p>
<p>每个服务器都有一份自己的日志副本，但是 Follower 的日志最终会和 Leader 日志保持一致。每个日志条目都存储了一条命令以及其他信息，它的具体结构如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Entry</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Term</span> <span class="kt">int64</span>
	<span class="nx">Index</span> <span class="kt">int64</span>
	<span class="nx">Command</span> <span class="nx">Command</span>
	<span class="o">...</span>
<span class="p">}</span>
</code></pre></div><p>其中必定包含的是：</p>
<ul>
<li>Index：日志条目的位置</li>
<li>Term：日志条目被创建时的任期号</li>
<li>命令</li>
</ul>
<h2 id="日志提交">日志提交</h2>
<p>在 Leader 把一条日志复制到大多数服务器之后，日志就被提交，并且 Raft 算法保证已经提交的日志是持久化的，并且最终会被所有可用的状态机执行。注意：提交操作同样也会提交领导者日志中所有之前的条目，包括之前领导者创建的条目。日志被提交之后，才能被安全地应用到状态机。</p>
<p>日志的复制提交流程如下：</p>
<ol>
<li>客户端向 Leader 发送命令；</li>
<li>Leader 先把命令追加到自己的日志中，然后 Leader 并行地向其它节点发送 <code>AppendEntries</code> RPC，等待响应；</li>
<li>收到超过半数节点的响应，则认为新的日志记录是被提交的：
<ul>
<li>Leader 将命令应用到状态机，然后向客户端返回响应</li>
<li>此外，一旦 Leader 知道一条记录被提交了，将在后续的 <code>AppendEntries</code> RPC 中通知已经提交记录的 Followers</li>
<li>Follower 将已提交的命令传给自己的状态机</li>
</ul>
</li>
<li>如果 Follower 宕机/超时：Leader 将反复尝试发送 RPC；</li>
</ol>
<h2 id="日志匹配log-matching">日志匹配（Log Matching）</h2>
<p>Raft 的日志机制，使得在不同服务器上的日志之间保持高度的一致性。Raft 同样为日志维持了以下两个属性：</p>
<ol>
<li>如果在不同服务器间的两个日志有相同的 <code>index</code> 和 <code>term</code>，那么他们存储了相同的命令；</li>
<li>如果在不同服务器间的两个日志有相同的 <code>index</code> 和 <code>term</code>，那么日志中的所有前面的条目都是相同的。</li>
</ol>
<h3 id="appendentries-一致性检查">AppendEntries 一致性检查</h3>
<p>为了维持上面的两个属性，Follower 在收到 Leader 的 <code>AppendEntries</code> RPC 时会进行一致性检查。</p>
<p>Leader 为每个 Follower 维护了一个 <code>nextIndex</code> 变量，表示下一个将要发送给 Follower 的日志的 index。当 Leader就任时，它将所有 Follower 的 nextIndex 初始化为其日志中最后一个索引之后的索引。</p>
<p>当 <code>AppendEntries</code> RPC 发送：</p>
<ul>
<li>对于每个 <code>AppendEntries</code> RPC 包含新日志<strong>之前那条日志的</strong>索引(<code>prevLogIndex</code>)和任期(<code>prevLogTerm</code> )；</li>
<li>Follower 检查自己的 index 和 term 是否与 <code>prevLogIndex</code> 和 <code>prevLogTerm</code> 匹配，匹配则接收该日志；否则拒绝；</li>
<li>Leader 的 RPC 被拒绝后，他会回退 nextIndex 到之前的某个点，然后重试，知道成功为止。</li>
</ul>
<h1 id="6-安全性">6. 安全性</h1>
<p>为了保证状态机的一致性，**Raft 保证之前任期已提交的所有日志都会出现在之后的新 Leader 的日志中，一旦 Leader 的状态机执行了一条日志里的命令，必须确保其它状态机在同样索引的位置不会执行不同的命令。**前面的章节中，并没有对选举做出任何限制，所以选举过程存在安全性问题。例如，当领导者提交几个日志条目时，一个跟随者可能无法使用，然后它可能被选为领导者，并用新的条目覆盖这些条目；结果，不同的状态机可能执行不同的命令序列，导致了状态机的不一致。</p>
<p><img src="https://blog-wero.oss-cn-shanghai.aliyuncs.com/img/raft-commited-log.png" alt=""></p>
<h2 id="选举限制">选举限制</h2>
<p>Raft 使用选举来阻止某些 Candidate 成为 Leader，除非他们已经包含了已提交的全部日志。Raft 通过 <code>RequestVote</code> RPC 调用来实现选举限制：</p>
<ul>
<li>RPC 包括 Candidate 的日志信息；</li>
<li>如果投票者自己的日志比 Candidate 的日志<code>更新</code>，则投票者会拒绝投票。</li>
</ul>
<p>Raft 通过比较两个服务器日志中的最后一条日志条目的 index 和 term 来判断哪个服务器的日志更新：</p>
<ol>
<li>如果两个日志条目有不同的 term，那么 term 大的日志条目的服务器更新；</li>
<li>如果两个日志条目有相同的 term，那么 index 更大的日志条目的服务器更新；</li>
</ol>
<h2 id="提交以前任期的日志">提交以前任期的日志</h2>
<p>当新的 Leader 上任时，如果对以前任期的日志复制和提交方式不加限制，那么可能会导致一些不一致性。</p>
<p>我们来看个例子：</p>
<p><img src="https://blog-wero.oss-cn-shanghai.aliyuncs.com/img/raft-log-bad-commit-rule.png" alt=""></p>
<p>一个时间序列显示了为什么Leader不能使用 old term 的日志条目来决定是否提交日志。</p>
<p>上图描述了旧的日志就算被存储在大多数服务器，也能够被未来的新的 Leader 给覆盖掉，这就导致了不一致性。</p>
<p>(a) S1 是 Leader，复制了 Index2 的日志到 S2；</p>
<p>(b) S1 崩溃，S5 成为 Leader（选票来自S3,S4,自己），并且在 Index2 产生了的日志；</p>
<p>(c) S5 崩溃，S1 成为了 Leader，接着，他把之前<code>未提交的 term2 的日志</code>复制到了大多数节点，下面可能发生 d,e两种情况</p>
<p>(d) S1 崩溃，S5成为 Leader，然后他把之前<code>未提交的 term3 的日志</code>复制到了大多数节点，并且用 term3 的日志覆盖了 S1 在 (c) 阶段复制的日志；</p>
<p>(e) S1 把当前任期 4 的日志复制到大多数节点，并且提交，这也间接提交了之前任期的日志，这时 S5 便能成为 Leader，所有之前任期的日志也被提交。</p>
<p>为了消除这个问题，Raft 提出：</p>
<ol>
<li>Leader 不会通过副本计数来提交之前任期的日志，只有 Leader 当前任期的日志才能通过副本计数来提交，一旦当前任期的日志被提交，那么之前任期的日志也就会通过之前描述的日志匹配规则间接提交。</li>
<li><strong>Leader 不能单独提交以前任期的日志，必须通过当前任期的日志提交来间接提交以前任期的日志</strong></li>
</ol>
<p>结合上面新的选举和日志提交规则，我们可以保证 Raft 的安全性。具体的论证可以看 Raft 论文的 5.4.3节。</p>
]]></content>
		</item>
		
		<item>
			<title>设计模式-工厂模式</title>
			<link>https://wangzeping722.github.io/posts/go-pattern-factory/</link>
			<pubDate>Fri, 18 Jun 2021 15:30:15 +0800</pubDate>
			
			<guid>https://wangzeping722.github.io/posts/go-pattern-factory/</guid>
			<description>工厂模式可以细分为简单工厂模式、工厂方法模式以及抽象工厂模式 。 简单工厂 当对象的创建逻辑很简单，不需要太多的初始化操作时，可以选择简单工厂模式</description>
			<content type="html"><![CDATA[<p>工厂模式可以细分为<code>简单工厂模式</code>、<code>工厂方法模式</code>以及<code>抽象工厂模式</code> 。</p>
<h2 id="简单工厂">简单工厂</h2>
<p>当对象的创建逻辑很简单，不需要太多的初始化操作时，可以选择简单工厂模式。</p>
<p>Go 语言本身没有构造函数，所以实现简单工厂就可以直接使用 <code>NewXXX</code> 这种方式来实现，并且返回一个接口：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">factory</span>

<span class="kd">type</span> <span class="nx">IRuleConfigParser</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Parse</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">JsonRuleConfigParser</span> <span class="kd">struct</span> <span class="p">{</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">j</span> <span class="nx">JsonRuleConfigParser</span><span class="p">)</span> <span class="nf">Parse</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;implement me&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">XmlRuleConfigParser</span> <span class="kd">struct</span> <span class="p">{</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">j</span> <span class="nx">XmlRuleConfigParser</span><span class="p">)</span> <span class="nf">Parse</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;implement me&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">NewIRuleConfigParser</span><span class="p">(</span><span class="nx">parserType</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">IRuleConfigParser</span> <span class="p">{</span>
	<span class="k">switch</span> <span class="nx">parserType</span> <span class="p">{</span>
	<span class="k">case</span> <span class="s">&#34;json&#34;</span><span class="p">:</span>
		<span class="k">return</span> <span class="nx">JsonRuleConfigParser</span><span class="p">{}</span>
	<span class="k">case</span> <span class="s">&#34;xml&#34;</span><span class="p">:</span>
		<span class="k">return</span> <span class="nx">XmlRuleConfigParser</span><span class="p">{}</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="工厂方法">工厂方法</h2>
<p>当对象的创建逻辑比较复杂，不只是简单的 <code>new</code> 一下就可以，而是要组合其他类对象，做各种初始化操作的时候，推荐使用工厂方法模式，将复杂的创建逻辑拆分到多个工厂类中，每个工厂类都负责一种类型对象的创建：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">factory</span>

<span class="kd">type</span> <span class="nx">IRuleConfigParserFactory</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">CreateRuleConfigParser</span><span class="p">()</span> <span class="nx">IRuleConfigParser</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">JsonRuleConfigParserFactory</span> <span class="kd">struct</span> <span class="p">{</span>

<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">j</span> <span class="nx">JsonRuleConfigParserFactory</span><span class="p">)</span> <span class="nf">CreateRuleConfigParser</span><span class="p">()</span> <span class="nx">IRuleConfigParser</span> <span class="p">{</span>
	<span class="c1">// doSomething
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">JsonRuleConfigParser</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">XmlRuleConfigParserFactory</span> <span class="kd">struct</span> <span class="p">{</span>

<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">j</span> <span class="nx">XmlRuleConfigParserFactory</span><span class="p">)</span> <span class="nf">CreateRuleConfigParser</span><span class="p">()</span> <span class="nx">IRuleConfigParser</span> <span class="p">{</span>
	<span class="c1">// doSomething
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">XmlRuleConfigParser</span><span class="p">{}</span>
<span class="p">}</span>

<span class="c1">// NewIRuleConfigParserFactory 用一个简单工厂封装工厂方法
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewIRuleConfigParserFactory</span><span class="p">(</span><span class="nx">t</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">IRuleConfigParserFactory</span> <span class="p">{</span>
	<span class="k">switch</span> <span class="nx">t</span> <span class="p">{</span>
	<span class="k">case</span> <span class="s">&#34;json&#34;</span><span class="p">:</span>
		<span class="k">return</span> <span class="nx">JsonRuleConfigParserFactory</span><span class="p">{}</span>
	<span class="k">case</span> <span class="s">&#34;xml&#34;</span><span class="p">:</span>
		<span class="k">return</span> <span class="nx">XmlRuleConfigParserFactory</span><span class="p">{}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>工厂方法模式比起简单工厂模式更加符合开闭原则。</p>
<h2 id="抽象工厂">抽象工厂</h2>
<p>抽象工厂让一个工厂负责创建多个不同类型的对象（IRuleConfigParser、ISystemConfigParser 等），而不是只创建一种 parser 对象。</p>
<p>该模式用得比较少，故不做讨论。</p>
]]></content>
		</item>
		
		<item>
			<title>逻辑题</title>
			<link>https://wangzeping722.github.io/posts/logic/</link>
			<pubDate>Sat, 24 Apr 2021 20:11:25 +0800</pubDate>
			
			<guid>https://wangzeping722.github.io/posts/logic/</guid>
			<description>平时收藏的一些逻辑题，不定期更新。 1. 有n个球，两个人轮流拿，每次只能拿【1，7】个，就是一次最少拿一个，最多一次拿7个，最后拿的最后赢，如何</description>
			<content type="html"><![CDATA[<p>平时收藏的一些逻辑题，不定期更新。</p>
<h3 id="1-有n个球两个人轮流拿每次只能拿17个就是一次最少拿一个最多一次拿7个最后拿的最后赢如何保证谁稳赢">1. 有n个球，两个人轮流拿，每次只能拿【1，7】个，就是一次最少拿一个，最多一次拿7个，最后拿的最后赢，如何保证谁稳赢？</h3>
<p>思路：这个题应该从倍数的方向考虑，因为每次最多取7 个，最少去 1 个，那么只需要思考每次取 8 的倍数，就一定会在最后拿完所有的球取得胜利</p>
<p>所以 n/8 = m &hellip; x,</p>
<ol>
<li>x  != 0 的情况下，第一个人先拿 x 个球，x &gt;=1且 x&lt;=7，第一个人永远可以补齐 8，获得最后拿球的机会。</li>
<li>x == 0 的情况下，第一个人永远拿不到最后一个球，也能保证第二个人稳赢。</li>
</ol>
]]></content>
		</item>
		
		<item>
			<title>Term Color</title>
			<link>https://wangzeping722.github.io/posts/term-color/</link>
			<pubDate>Sat, 17 Apr 2021 12:01:11 +0800</pubDate>
			
			<guid>https://wangzeping722.github.io/posts/term-color/</guid>
			<description>ANSI转义序列（ANSI escape sequences）是一种的标准，用于控制视频文本上的光标位置、颜色和其他选项。在文本中嵌入确定的字节序列，大部</description>
			<content type="html"><![CDATA[<p>ANSI转义序列（ANSI escape sequences）是一种的标准，用于控制视频文本上的光标位置、颜色和其他选项。在文本中嵌入确定的字节序列，大部分以和&quot;。通过键入这些特殊的字符串，我们可以实现终端的颜色输出。
控制代码如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">代码</th>
<th style="text-align:center">作用</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">重置/正常</td>
<td style="text-align:center">关闭所有属性。</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">粗体或增加强度</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">弱化（降低强度）</td>
<td style="text-align:center">未广泛支持。</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">斜体</td>
<td style="text-align:center">未广泛支持。有时视为反相显示。</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">下划线</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">缓慢闪烁</td>
<td style="text-align:center">低于每分钟150次。</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">快速闪烁</td>
<td style="text-align:center">MS-DOS ANSI.SYS；每分钟150以上；未广泛支持。</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">反显</td>
<td style="text-align:center">前景色与背景色交换。</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">隐藏</td>
<td style="text-align:center">未广泛支持。</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">划除</td>
<td style="text-align:center">字符清晰，但标记为删除。未广泛支持。</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">主要（默认）字体</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">11–19</td>
<td style="text-align:center">替代字体</td>
<td style="text-align:center">选择替代字体{\displaystyle n-10}<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f84f9418cc9f1de8428f11785ae95b5415b425c5" alt="{\displaystyle n-10}">。</td>
</tr>
<tr>
<td style="text-align:center">20</td>
<td style="text-align:center"><a href="https://zh.wikipedia.org/wiki/%E5%BE%B7%E6%96%87%E5%B0%96%E8%A7%92%E9%AB%94">尖角体</a></td>
<td style="text-align:center">几乎无支持。</td>
</tr>
<tr>
<td style="text-align:center">21</td>
<td style="text-align:center">关闭粗体或双下划线</td>
<td style="text-align:center">关闭粗体未广泛支持；双下划线几乎无支持。</td>
</tr>
<tr>
<td style="text-align:center">22</td>
<td style="text-align:center">正常颜色或强度</td>
<td style="text-align:center">不强不弱。</td>
</tr>
<tr>
<td style="text-align:center">23</td>
<td style="text-align:center">非斜体、非尖角体</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">24</td>
<td style="text-align:center">关闭下划线</td>
<td style="text-align:center">去掉单双下划线。</td>
</tr>
<tr>
<td style="text-align:center">25</td>
<td style="text-align:center">关闭闪烁</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">27</td>
<td style="text-align:center">关闭反显</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">28</td>
<td style="text-align:center">关闭隐藏</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">29</td>
<td style="text-align:center">关闭划除</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">30–37</td>
<td style="text-align:center">设置前景色</td>
<td style="text-align:center">参见下面的颜色表。</td>
</tr>
<tr>
<td style="text-align:center">38</td>
<td style="text-align:center">设置前景色</td>
<td style="text-align:center">下一个参数是<code>5;n</code>或<code>2;r;g;b</code>，见下。</td>
</tr>
<tr>
<td style="text-align:center">39</td>
<td style="text-align:center">默认前景色</td>
<td style="text-align:center">由具体实现定义（按照标准）。</td>
</tr>
<tr>
<td style="text-align:center">40–47</td>
<td style="text-align:center">设置背景色</td>
<td style="text-align:center">参见下面的颜色表。</td>
</tr>
<tr>
<td style="text-align:center">48</td>
<td style="text-align:center">设置背景色</td>
<td style="text-align:center">下一个参数是<code>5;n</code>或<code>2;r;g;b</code>，见下。</td>
</tr>
<tr>
<td style="text-align:center">49</td>
<td style="text-align:center">默认背景色</td>
<td style="text-align:center">由具体实现定义（按照标准）。</td>
</tr>
<tr>
<td style="text-align:center">51</td>
<td style="text-align:center">Framed</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">52</td>
<td style="text-align:center">Encircled</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">53</td>
<td style="text-align:center">上划线</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">54</td>
<td style="text-align:center">Not framed or encircled</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">55</td>
<td style="text-align:center">关闭上划线</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">60</td>
<td style="text-align:center">表意文字下划线或右边线</td>
<td style="text-align:center">几乎无支持。</td>
</tr>
<tr>
<td style="text-align:center">61</td>
<td style="text-align:center">表意文字双下划线或双右边线</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">62</td>
<td style="text-align:center">表意文字上划线或左边线</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">63</td>
<td style="text-align:center">表意文字双上划线或双左边线</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">64</td>
<td style="text-align:center">表意文字着重标志</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">65</td>
<td style="text-align:center">表意文字属性关闭</td>
<td style="text-align:center">重置<code>60</code>–<code>64</code>的所有效果。</td>
</tr>
<tr>
<td style="text-align:center">90–97</td>
<td style="text-align:center">设置明亮的前景色</td>
<td style="text-align:center">aixterm（非标准）。</td>
</tr>
<tr>
<td style="text-align:center">100–107</td>
<td style="text-align:center">设置明亮的背景色</td>
<td style="text-align:center">aixterm（非标准）。</td>
</tr>
</tbody>
</table>
<p>推荐实现如下几个等级的输出，输出优先级依次降低：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>颜色</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>ERROR</td>
<td>红色(31)</td>
<td>表示发生严重错误，很可能或者已经导致程序崩溃</td>
</tr>
<tr>
<td>WARN</td>
<td>黄色(93)</td>
<td>表示发生不常见情况，但是并不一定导致系统错误</td>
</tr>
<tr>
<td>INFO</td>
<td>蓝色(34)</td>
<td>比较中庸的选项，输出比较重要的信息，比较常用</td>
</tr>
<tr>
<td>DEBUG</td>
<td>绿色(32)</td>
<td>输出信息较多，在 debug 时使用</td>
</tr>
<tr>
<td>TRACE</td>
<td>灰色(90)</td>
<td>最详细的输出，跟踪了每一步关键路径的执行</td>
</tr>
</tbody>
</table>
<p>比如我们要输出绿底红字，那么就可以这样：</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="nb">echo</span> -e <span class="s2">&#34;\x1b[31;42mhello world\x1b[0m&#34;</span>
</code></pre></div><p><a href="https://zh.wikipedia.org/wiki/ANSI%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97">wiki</a></p>
]]></content>
		</item>
		
		<item>
			<title>Rust学习——trait</title>
			<link>https://wangzeping722.github.io/posts/rust-learn-trait/</link>
			<pubDate>Sat, 10 Apr 2021 17:30:17 +0800</pubDate>
			
			<guid>https://wangzeping722.github.io/posts/rust-learn-trait/</guid>
			<description>trait 是 Rust 的灵魂。从语义上来说，trait 是在行为上对类型的约束，这种约束可以让 trait 有如下四种用法： 接口抽象：接口是对类型行为的统一约束； 泛型约束</description>
			<content type="html"><![CDATA[<p>trait 是 Rust 的灵魂。从语义上来说，trait 是在行为上对类型的约束，这种约束可以让 trait 有如下四种用法：</p>
<ul>
<li>接口抽象：接口是对类型行为的统一约束；</li>
<li>泛型约束：泛型的行为被 trait 限定在更有限的范围内；</li>
<li>抽象类型：在运行时可以作为一种间接的抽象类型去使用，动态的分发给具体的类型，但是有一定的性能开销；</li>
<li>标签 trait：对类型的约束，可以直接作为一种“标签”使用。</li>
</ul>
<h2 id="接口抽象">接口抽象</h2>
<p>trait 最基础的用法就是进行接口抽象，可以看做是其他语言中的 interface，例如 golang 中的 interface 定义了一些行为：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Cat</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">Miao</span><span class="p">()</span> <span class="kt">string</span>
    <span class="nf">Parkour</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="c1">// rust 中的 trait
</span><span class="c1"></span><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">Cat</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">miao</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">parkour</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">String</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>看起来是不是如出一辙，trait 告诉 Rust 编译器某个特定类型拥有可能与其他类型共享的功能。可以通过 trait 以一种抽象的方式定义共享的行为。其特点如下：</p>
<ul>
<li>接口中可以定义方法，并且支持默认实现；</li>
<li>接口中不能实现另一个接口，但是接口之间可以继承；</li>
<li>如果要实现某个 trait，那么该 trait 和要实现该 trait 的那个类型至少有一个要在当前 crate 中定义。</li>
</ul>
<h3 id="trait-继承">trait 继承</h3>
<p>Rust 不支持传统面向对象的继承，但是支持 trait 继承。子 trait 可以继承父 trait 中定义或实现的方法。例如：</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">trait</span><span class="w"> </span><span class="n">People</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">speak</span><span class="p">();</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">walk</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">Teacher</span>: <span class="nc">People</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">teach_student</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>需要注意的是包含 trait 限定的泛型属于静态分发，所以调用 trait 限定中的方法也都是零成本。</p>
<h2 id="泛型约束">泛型约束</h2>
<p>在使用泛型时，如果想限定能够使用该泛型行为的对象时，就可以给改泛型加上 trait 约束。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">ops</span>::<span class="n">Add</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">sum</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">Add</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">Output</span><span class="o">=</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">a</span>: <span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="n">b</span>: <span class="nc">T</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">T</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">assert_eq</span><span class="o">!</span><span class="p">(</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="k">u32</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="k">u32</span><span class="p">),</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><h2 id="抽象类型">抽象类型</h2>
<p>trait 还可以用来当作抽象类型，抽象类型是类型系统的一种，也叫做存在类型。相对于具体类型而言，抽象类型无法直接实例化，他的每个实例都是具体类型的实例。</p>
<p>编译器可能无法确定抽象类型的确切功能和所占空间大小，所以 Rust 目前有两种方法来处理抽象类型：▪<code>trait对象</code>▪ 和 ▪<code>impl Trait</code>▪。</p>
<h3 id="trait-对象">trait 对象</h3>
<p>trait 对象就是拥有相同行为的类型的抽象对象，也称为 <code>Trait Object</code>。需要记住的是，用 trait 限定的泛型参数是属于静态分发，而使用 trait object 属于动态分发，两者在性能上是有差别的。</p>
<div class="highlight"><pre class="chroma"><code class="language-rust" data-lang="rust"><span class="cp">#[derive(Debug)]</span><span class="w">
</span><span class="w"></span><span class="k">struct</span> <span class="nc">Foo</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">trait</span><span class="w"> </span><span class="n">Bar</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">baz</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Bar</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="k">fn</span> <span class="nf">baz</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&#34;{:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">static_dispatch</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">T</span><span class="p">)</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">T</span>: <span class="nc">Bar</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">t</span><span class="p">.</span><span class="n">baz</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">dynamic_dispatch</span><span class="p">(</span><span class="n">t</span>: <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="n">Bar</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="n">t</span><span class="p">.</span><span class="n">baz</span><span class="p">();</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Foo</span><span class="p">;</span><span class="w">
</span><span class="w">    </span><span class="n">static_dispatch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">foo</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="n">dynamic_dispatch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">foo</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>trait 本身就是一种抽象而非具体类型，所有他的类型在编译期是不确定的，所以 trait 对象需要使用胖指针，可以利用&amp;或者 Box 来指针一个 trait 对象。Trait Object 包括两个指针：data 指针和 vtable 指针。vtable包含了 Trait Object 的方法、析构函数、大小和对齐等信息。</p>
<p><img src="https://blog-wero.oss-cn-shanghai.aliyuncs.com/img/traitobject.png" alt="img"></p>
<p>trait object 会根据虚表指针中查出正确的函数指针，然后再进行动态调用。</p>
<h2 id="标签-trait">标签 trait</h2>
<p>利用 trait 的特性，我们也可以用 trait 来给类型加上标签，Rust 提供了 5 个重要的标签 trait，都被定义在标准库 std::maker 模块中。</p>
<p>它们分别是：</p>
<ul>
<li>Sized trait：用来标识编译期可确定大小的类型。</li>
<li>Unsize trait：用于标识动态大小类型（DST）。</li>
<li>Copy trait：用来标识可以安全按位复制其值的类型。</li>
<li>Send trait：用来标识可以跨线程安全通信的类型。</li>
<li>Sync trait：用来标识可以在线程间安全共享引用的类型</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>go-zero源码分析： P2C 负载均衡算法</title>
			<link>https://wangzeping722.github.io/posts/go-zero-balancer-p2c/</link>
			<pubDate>Mon, 11 Jan 2021 16:30:18 +0800</pubDate>
			
			<guid>https://wangzeping722.github.io/posts/go-zero-balancer-p2c/</guid>
			<description>看完文章基于gRPC的注册发现与负载均衡的原理和实战后大呼过瘾，但是文章中对负载均衡算法—— p2c 算法的介绍不是很详细，于是乎就去学习了一下。 1.</description>
			<content type="html"><![CDATA[<p>看完文章<a href="https://mp.weixin.qq.com/s/olPGfrFczo22rhpPLBmpNw">基于gRPC的注册发现与负载均衡的原理和实战</a>后大呼过瘾，但是文章中对负载均衡算法—— p2c 算法的介绍不是很详细，于是乎就去学习了一下。</p>
<h2 id="1-p2c-负载均衡算法介绍">1. P2C 负载均衡算法介绍</h2>
<p>P2C 的全称是 <strong>Power of Two Choices (P2C，两次随机选择) 负载均衡算法</strong>，相比其他负载均衡算法有着更加科学的 LB 策略，它通过随机选择出两个节点，然后根据一些条件计算出两个节点的负载情况，选择出负载小的那个节点。</p>
<p>伪代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">node1</span> <span class="o">:=</span> <span class="nf">randomNode</span><span class="p">()</span>
<span class="nx">node2</span> <span class="o">:=</span> <span class="nf">randomNode</span><span class="p">()</span>
<span class="nx">best</span> <span class="o">:=</span> <span class="nf">choiceTheBest</span><span class="p">(</span><span class="nx">node1</span><span class="p">,</span> <span class="nx">node2</span><span class="p">)</span>
</code></pre></div><p>P2C 是在客户端侧实现的负载均衡算法，所以不可避免的要有评判节点连接负载高低的方法，只要知道负载率，那么就能够选出最优的节点。在 go-zero 中每个节点的负载情况都是由几个统计字段记录的，并通过这几个字段能够计算出节点连接当前的负载情况。</p>
<h3 id="11-lag">1.1 lag</h3>
<p>lag 是节点延迟，根据*EWMA（<a href="https://www.cnblogs.com/jiangxinyang/p/9705198.html">指数加权移动平均算法</a>）*计算出来，此算法，是对观察值分别给予不同的权数，按不同权数求得移动平均值，并以最后的移动平均值为基础，确定预测值的方法。采用加权移动平均法，是因为观察期的近期观察值对预测值有较大影响，它更能反映近期变化的趋势。</p>
<ul>
<li>指数移动加权平均法，是指各数值的加权系数随时间呈指数式递减，越靠近当前时刻的数值加权系数就越大</li>
<li>指数移动加权平均较传统的平均法来说，一是不需要保存过去所有的数值；二是计算量显著减小</li>
</ul>
<p>其中 EWMA 公式如下：
$$
X_i=w*X_{i-1}+(1-w)*X_{cur}
$$
EWMA 算法中 β 的计算公式（<a href="http://www.ruanyifeng.com/blog/2012/03/ranking_algorithm_newton_s_law_of_cooling.html">牛顿冷却定律</a>）也在这里一并给出，其中 decayTime 可根据自己的业务需求进行调整：</p>
<pre><code>w := math.Exp(float64(-td) / float64(decayTime))
</code></pre><h3 id="12-inflight">1.2 inflight</h3>
<p>代表节点的当前正在处理的请求数，即反应了节点的拥塞程度。</p>
<h3 id="13-success">1.3 success</h3>
<p>节点请求的成功率，初始化为 1000，当成功率低于 500 的时候，当前节点就会被判定为不健康。success 同样是根据 EWMA 计算出来的。</p>
<h2 id="2-go-zero-中对-p2c-算法的实现">2. go-zero 中对 P2C 算法的实现</h2>
<p>我们可以看见在 p2c 包里面对 gRPC 的 subConn 进行了包装，每个连接都有自己的统计数据：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">subConn</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">addr</span>     <span class="nx">resolver</span><span class="p">.</span><span class="nx">Address</span>
	<span class="nx">conn</span>     <span class="nx">balancer</span><span class="p">.</span><span class="nx">SubConn</span>
	<span class="nx">lag</span>      <span class="kt">uint64</span>	<span class="c1">// 延迟
</span><span class="c1"></span>	<span class="nx">inflight</span> <span class="kt">int64</span>  <span class="c1">// 节点当前正在处理的请求数
</span><span class="c1"></span>	<span class="nx">success</span>  <span class="kt">uint64</span> <span class="c1">// 请求成功率
</span><span class="c1"></span>	<span class="nx">requests</span> <span class="kt">int64</span>
	<span class="nx">last</span>     <span class="kt">int64</span>
	<span class="nx">pick</span>     <span class="kt">int64</span>
<span class="p">}</span>
</code></pre></div><p>当要选择一个节点进行请求的时候就会调用 Pick 函数：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">p2cPicker</span><span class="p">)</span> <span class="nf">Pick</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">info</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">PickInfo</span><span class="p">)</span> <span class="p">(</span>
	<span class="nx">conn</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">SubConn</span><span class="p">,</span> <span class="nx">done</span> <span class="kd">func</span><span class="p">(</span><span class="nx">balancer</span><span class="p">.</span><span class="nx">DoneInfo</span><span class="p">),</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">p</span><span class="p">.</span><span class="nx">lock</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">p</span><span class="p">.</span><span class="nx">lock</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

	<span class="kd">var</span> <span class="nx">chosen</span> <span class="o">*</span><span class="nx">subConn</span>
	<span class="k">switch</span> <span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">conns</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span><span class="p">:</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">ErrNoSubConnAvailable</span>
	<span class="k">case</span> <span class="mi">1</span><span class="p">:</span>
		<span class="nx">chosen</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">choose</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">conns</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="k">case</span> <span class="mi">2</span><span class="p">:</span>
		<span class="nx">chosen</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">choose</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">conns</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">p</span><span class="p">.</span><span class="nx">conns</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="kd">var</span> <span class="nx">node1</span><span class="p">,</span> <span class="nx">node2</span> <span class="o">*</span><span class="nx">subConn</span>
    <span class="c1">// 循环 pickTimes 次，如果还没有取到健康的节点，就取最后一次的结果
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">pickTimes</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">a</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">r</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">conns</span><span class="p">))</span>
			<span class="nx">b</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">r</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">conns</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">b</span> <span class="o">&gt;=</span> <span class="nx">a</span> <span class="p">{</span>
				<span class="nx">b</span><span class="o">++</span>
			<span class="p">}</span>
			<span class="nx">node1</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">conns</span><span class="p">[</span><span class="nx">a</span><span class="p">]</span>
			<span class="nx">node2</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">conns</span><span class="p">[</span><span class="nx">b</span><span class="p">]</span>
			<span class="k">if</span> <span class="nx">node1</span><span class="p">.</span><span class="nf">healthy</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nx">node2</span><span class="p">.</span><span class="nf">healthy</span><span class="p">()</span> <span class="p">{</span>
				<span class="k">break</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="nx">chosen</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">choose</span><span class="p">(</span><span class="nx">node1</span><span class="p">,</span> <span class="nx">node2</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">atomic</span><span class="p">.</span><span class="nf">AddInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">chosen</span><span class="p">.</span><span class="nx">inflight</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="nx">atomic</span><span class="p">.</span><span class="nf">AddInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">chosen</span><span class="p">.</span><span class="nx">requests</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
  <span class="c1">// 回调函数
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">chosen</span><span class="p">.</span><span class="nx">conn</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nf">buildDoneFunc</span><span class="p">(</span><span class="nx">chosen</span><span class="p">),</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// 判断节点是否健康
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">subConn</span><span class="p">)</span> <span class="nf">healthy</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadUint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">success</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">throttleSuccess</span>
<span class="p">}</span>
</code></pre></div><p>这个函数实现了负载均衡的逻辑：</p>
<ul>
<li>首先会随机选择出两个节点；</li>
<li>然后分别计算出两个节点的负载；</li>
<li>选择出负载最小的节点。</li>
</ul>
<p>再来看看具体的 <code>choose</code> 方法：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">p2cPicker</span><span class="p">)</span> <span class="nf">choose</span><span class="p">(</span><span class="nx">c1</span><span class="p">,</span> <span class="nx">c2</span> <span class="o">*</span><span class="nx">subConn</span><span class="p">)</span> <span class="o">*</span><span class="nx">subConn</span> <span class="p">{</span>
	<span class="nx">start</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">timex</span><span class="p">.</span><span class="nf">Now</span><span class="p">())</span>
	<span class="k">if</span> <span class="nx">c2</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c1</span><span class="p">.</span><span class="nx">pick</span><span class="p">,</span> <span class="nx">start</span><span class="p">)</span>
		<span class="k">return</span> <span class="nx">c1</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">c1</span><span class="p">.</span><span class="nf">load</span><span class="p">()</span> <span class="p">&gt;</span> <span class="nx">c2</span><span class="p">.</span><span class="nf">load</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">c1</span><span class="p">,</span> <span class="nx">c2</span> <span class="p">=</span> <span class="nx">c2</span><span class="p">,</span> <span class="nx">c1</span>
	<span class="p">}</span>

	<span class="nx">pick</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c2</span><span class="p">.</span><span class="nx">pick</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">start</span><span class="o">-</span><span class="nx">pick</span> <span class="p">&gt;</span> <span class="nx">forcePick</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c2</span><span class="p">.</span><span class="nx">pick</span><span class="p">,</span> <span class="nx">pick</span><span class="p">,</span> <span class="nx">start</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">c2</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c1</span><span class="p">.</span><span class="nx">pick</span><span class="p">,</span> <span class="nx">start</span><span class="p">)</span>
		<span class="k">return</span> <span class="nx">c1</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 节点的负载情况
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">subConn</span><span class="p">)</span> <span class="nf">load</span><span class="p">()</span> <span class="kt">int64</span> <span class="p">{</span>
	<span class="c1">// plus one to avoid multiply zero
</span><span class="c1"></span>	<span class="nx">lag</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nf">Sqrt</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadUint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lag</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
	<span class="nx">load</span> <span class="o">:=</span> <span class="nx">lag</span> <span class="o">*</span> <span class="p">(</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">inflight</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">load</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">penalty</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">load</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>可以看见，choose 做的工作也很少，就是比较两个节点的负载情况，然后选择负载最低的那个节点。看到这里，不免心生疑问，前面提到的 lag，success 究竟是在哪里完成的计算呀。其实是在节点完成 rpc 调用之后，会调用一个回调函数：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">p2cPicker</span><span class="p">)</span> <span class="nf">buildDoneFunc</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">subConn</span><span class="p">)</span> <span class="kd">func</span><span class="p">(</span><span class="nx">info</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">DoneInfo</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">start</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">timex</span><span class="p">.</span><span class="nf">Now</span><span class="p">())</span>
	<span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">info</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">DoneInfo</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">AddInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">inflight</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1">// 当前时间
</span><span class="c1"></span>		<span class="nx">now</span> <span class="o">:=</span> <span class="nx">timex</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>
    <span class="c1">// 上一次调用的时间
</span><span class="c1"></span>		<span class="nx">last</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">SwapInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">last</span><span class="p">,</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">now</span><span class="p">))</span>
    <span class="c1">// 获取时间间隔
</span><span class="c1"></span>		<span class="nx">td</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">now</span><span class="p">)</span> <span class="o">-</span> <span class="nx">last</span>
		<span class="k">if</span> <span class="nx">td</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">td</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="p">}</span>
    <span class="c1">// 获取时间衰减系数
</span><span class="c1"></span>		<span class="nx">w</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Exp</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="o">-</span><span class="nx">td</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">decayTime</span><span class="p">))</span>
    <span class="c1">// 获取调用延时
</span><span class="c1"></span>		<span class="nx">lag</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">now</span><span class="p">)</span> <span class="o">-</span> <span class="nx">start</span>
		<span class="k">if</span> <span class="nx">lag</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">lag</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="p">}</span>
		<span class="nx">olag</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadUint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lag</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">olag</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">w</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="p">}</span>
    <span class="c1">// 保存本地计算出的延迟数据
</span><span class="c1"></span>		<span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreUint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lag</span><span class="p">,</span> <span class="nb">uint64</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">olag</span><span class="p">)</span><span class="o">*</span><span class="nx">w</span><span class="o">+</span><span class="nb">float64</span><span class="p">(</span><span class="nx">lag</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="nx">w</span><span class="p">)))</span>
    <span class="c1">// success 的计算逻辑同上
</span><span class="c1"></span>		<span class="nx">success</span> <span class="o">:=</span> <span class="nx">initSuccess</span>
		<span class="k">if</span> <span class="nx">info</span><span class="p">.</span><span class="nx">Err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">codes</span><span class="p">.</span><span class="nf">Acceptable</span><span class="p">(</span><span class="nx">info</span><span class="p">.</span><span class="nx">Err</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">success</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="p">}</span>
		<span class="nx">osucc</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadUint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">success</span><span class="p">)</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreUint64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">success</span><span class="p">,</span> <span class="nb">uint64</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">osucc</span><span class="p">)</span><span class="o">*</span><span class="nx">w</span><span class="o">+</span><span class="nb">float64</span><span class="p">(</span><span class="nx">success</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="nx">w</span><span class="p">)))</span>

		<span class="nx">stamp</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">stamp</span><span class="p">.</span><span class="nf">Load</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">now</span><span class="o">-</span><span class="nx">stamp</span> <span class="o">&gt;=</span> <span class="nx">logInterval</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">stamp</span><span class="p">.</span><span class="nf">CompareAndSwap</span><span class="p">(</span><span class="nx">stamp</span><span class="p">,</span> <span class="nx">now</span><span class="p">)</span> <span class="p">{</span>
				<span class="nx">p</span><span class="p">.</span><span class="nf">logStats</span><span class="p">()</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="3-总结">3. 总结</h2>
<p>以上，便是对于 go-zero 中 P2C 算法的分析。</p>
<p>参考:</p>
<ul>
<li><a href="https://exceting.github.io/2020/08/13/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-P2C%E7%AE%97%E6%B3%95/">负载均衡-P2C算法</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>gRPC RoundRobin Picker 分析</title>
			<link>https://wangzeping722.github.io/posts/grpc-picker/</link>
			<pubDate>Mon, 09 Nov 2020 17:59:31 +0800</pubDate>
			
			<guid>https://wangzeping722.github.io/posts/grpc-picker/</guid>
			<description>前言 上一篇文章提到过：Picker 是负载均衡器里面的一个组件，主要作用就是客户端要进行 rpc 调用的时候，在可用的连接中根据负载均衡策略挑选出最时</description>
			<content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>上一篇文章提到过：Picker 是负载均衡器里面的一个组件，主要作用就是客户端要进行 rpc 调用的时候，在可用的连接中根据负载均衡策略挑选出最时候的连接交个 gRPC 进行调用。本文简单的分析一下 Picker 的原理，以及官方实现的 RoundRobin Picker。</p>
<h2 id="1-picker">1. Picker</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Picker is used by gRPC to pick a SubConn to send an RPC.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Picker</span> <span class="kd">interface</span> <span class="p">{</span>
   <span class="nf">Pick</span><span class="p">(</span><span class="nx">info</span> <span class="nx">PickInfo</span><span class="p">)</span> <span class="p">(</span><span class="nx">PickResult</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// PickResult contains information related to a connection chosen for an RPC.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">PickResult</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// SubConn is the connection to use for this pick, if its state is Ready.
</span><span class="c1"></span>	<span class="c1">// If the state is not Ready, gRPC will block the RPC until a new Picker is
</span><span class="c1"></span>	<span class="c1">// provided by the balancer (using ClientConn.UpdateState).  The SubConn
</span><span class="c1"></span>	<span class="c1">// must be one returned by ClientConn.NewSubConn.
</span><span class="c1"></span>	<span class="nx">SubConn</span> <span class="nx">SubConn</span>

	<span class="c1">// Done is called when the RPC is completed.  If the SubConn is not ready,
</span><span class="c1"></span>	<span class="c1">// this will be called with a nil parameter.  If the SubConn is not a valid
</span><span class="c1"></span>	<span class="c1">// type, Done may not be called.  May be nil if the balancer does not wish
</span><span class="c1"></span>	<span class="c1">// to be notified when the RPC completes.
</span><span class="c1"></span>	<span class="nx">Done</span> <span class="kd">func</span><span class="p">(</span><span class="nx">DoneInfo</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// DoneInfo contains additional information for done.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">DoneInfo</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// Err is the rpc error the RPC finished with. It could be nil.
</span><span class="c1"></span>	<span class="nx">Err</span> <span class="kt">error</span>
	<span class="c1">// Trailer contains the metadata from the RPC&#39;s trailer, if present.
</span><span class="c1"></span>	<span class="nx">Trailer</span> <span class="nx">metadata</span><span class="p">.</span><span class="nx">MD</span>
	<span class="c1">// BytesSent indicates if any bytes have been sent to the server.
</span><span class="c1"></span>	<span class="nx">BytesSent</span> <span class="kt">bool</span>
	<span class="c1">// BytesReceived indicates if any byte has been received from the server.
</span><span class="c1"></span>	<span class="nx">BytesReceived</span> <span class="kt">bool</span>
	<span class="c1">// ServerLoad is the load received from server. It&#39;s usually sent as part of
</span><span class="c1"></span>	<span class="c1">// trailing metadata.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// The only supported type now is *orca_v1.LoadReport.
</span><span class="c1"></span>	<span class="nx">ServerLoad</span> <span class="kd">interface</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre></div><p>Picker 接口只有一个 Pick 方法，用来返回一个可用的 <code>SubConn</code> 。需要注意的是，Pick 并不是直接返回一个 <code>SubConn</code>，而是返回了一个 <code>PickResult</code> ，里面包含了一个 <code>SubConn</code> ，以及一个 <code>Done func(DoneInfo)</code> 的闭包。从文档中可以看出，这个闭包是在 RPC 调用完成之后才被调用的。参数 <code>DoneInfo</code> 包含了调用以及服务器返回的信息。有经验的小伙伴肯定已经猜到了：<code>DoneInfo</code> 中的 Trailer 能够写到服务端信息（包括 CPU，内存，服务器状态等信息），这样就可以利用 DoneInfo 作为 Picker 以后 Pick 服务器的依据。</p>
<h2 id="2-rrpicker-实现">2. rrPicker 实现</h2>
<p>官方的实现很简单，这里就直接贴出代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">rrPickerBuilder</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="o">*</span><span class="nx">rrPickerBuilder</span><span class="p">)</span> <span class="nf">Build</span><span class="p">(</span><span class="nx">info</span> <span class="nx">base</span><span class="p">.</span><span class="nx">PickerBuildInfo</span><span class="p">)</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">Picker</span> <span class="p">{</span>
	<span class="nx">logger</span><span class="p">.</span><span class="nf">Infof</span><span class="p">(</span><span class="s">&#34;roundrobinPicker: newPicker called with info: %v&#34;</span><span class="p">,</span> <span class="nx">info</span><span class="p">)</span>
  <span class="c1">// 没有可用的连接，返回 errPicker
</span><span class="c1"></span>	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">info</span><span class="p">.</span><span class="nx">ReadySCs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">base</span><span class="p">.</span><span class="nf">NewErrPicker</span><span class="p">(</span><span class="nx">balancer</span><span class="p">.</span><span class="nx">ErrNoSubConnAvailable</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="kd">var</span> <span class="nx">scs</span> <span class="p">[]</span><span class="nx">balancer</span><span class="p">.</span><span class="nx">SubConn</span>
	<span class="k">for</span> <span class="nx">sc</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">info</span><span class="p">.</span><span class="nx">ReadySCs</span> <span class="p">{</span>
		<span class="nx">scs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">scs</span><span class="p">,</span> <span class="nx">sc</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">rrPicker</span><span class="p">{</span>
		<span class="nx">subConns</span><span class="p">:</span> <span class="nx">scs</span><span class="p">,</span>
		<span class="c1">// Start at a random index, as the same RR balancer rebuilds a new
</span><span class="c1"></span>		<span class="c1">// picker when SubConn states change, and we don&#39;t want to apply excess
</span><span class="c1"></span>		<span class="c1">// load to the first server in the list.
</span><span class="c1"></span>		<span class="nx">next</span><span class="p">:</span> <span class="nx">grpcrand</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">scs</span><span class="p">)),</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">rrPicker</span> <span class="kd">struct</span> <span class="p">{</span>
   <span class="c1">// subConns is the snapshot of the roundrobin balancer when this picker was
</span><span class="c1"></span>   <span class="c1">// created. The slice is immutable. Each Get() will do a round robin
</span><span class="c1"></span>   <span class="c1">// selection from it and return the selected SubConn.
</span><span class="c1"></span>   <span class="nx">subConns</span> <span class="p">[]</span><span class="nx">balancer</span><span class="p">.</span><span class="nx">SubConn</span>

   <span class="nx">mu</span>   <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
   <span class="nx">next</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">rrPicker</span><span class="p">)</span> <span class="nf">Pick</span><span class="p">(</span><span class="nx">balancer</span><span class="p">.</span><span class="nx">PickInfo</span><span class="p">)</span> <span class="p">(</span><span class="nx">balancer</span><span class="p">.</span><span class="nx">PickResult</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
   <span class="nx">p</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
   <span class="nx">sc</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">subConns</span><span class="p">[</span><span class="nx">p</span><span class="p">.</span><span class="nx">next</span><span class="p">]</span>
   <span class="c1">// 每次选择连接之后都会把 next 加 1，然后对长度取余，实现轮询所有连接
</span><span class="c1"></span>   <span class="nx">p</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">next</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">subConns</span><span class="p">)</span>
   <span class="nx">p</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
   <span class="k">return</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">PickResult</span><span class="p">{</span><span class="nx">SubConn</span><span class="p">:</span> <span class="nx">sc</span><span class="p">},</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>首先，负载均衡器会通过 <code>rrPickerBuilder.Build</code> 方法使用传入的 <code>SubConn</code> 来初始化 <code>rrPicker</code> 实例。当需要进行 RPC 调用时，gRPC 会调用 <code>Pick</code> 方法来获取一条可用连接。在 <code>rrPicker</code> 中，每次调用 Pick 都会把 <code>rrPicker.next</code> 值加1，然后对长度取余，实现轮询所有连接。</p>
<h2 id="3-总结">3. 总结</h2>
<p>gRPC 实现的 RoundRobin 非常简洁易懂，如果我们有自己实现负载均衡策略的需求，也可以参考 RoundRobin 的写法来构建自己的负载均衡选择器。比如 go-zero 的 <a href="https://github.com/tal-tech/go-zero/blob/master/zrpc/internal/balancer/p2c/p2c.go">p2c</a> 选择器。</p>
]]></content>
		</item>
		
		<item>
			<title>gRPC Balancer 分析</title>
			<link>https://wangzeping722.github.io/posts/grpc-balancer/</link>
			<pubDate>Fri, 06 Nov 2020 18:07:55 +0800</pubDate>
			
			<guid>https://wangzeping722.github.io/posts/grpc-balancer/</guid>
			<description>1. 负载均衡 gRPC 实现负载均衡的方法主要有三种，分别是 集中式 LB（Proxy Model） 进程内 LB（Balancing-aware Client） 独</description>
			<content type="html"><![CDATA[<h2 id="1-负载均衡">1. 负载均衡</h2>
<p>gRPC 实现负载均衡的方法主要有三种，分别是</p>
<ul>
<li>集中式 LB（Proxy Model）</li>
<li>进程内 LB（Balancing-aware Client）</li>
<li>独立 LB 进程（External Load Balancing Service）</li>
</ul>
<p>具体的实现方式请参考这篇文章<a href="https://segmentfault.com/a/1190000008672912">gRPC 服务发现&amp;负载均衡</a>。</p>
<p>需要注意的是，gRPC 使用 <strong>进程内 LB</strong> 的方案，并且是基于每次调用 RPC 接口实现的负载均衡， 如下图：</p>
<p><!-- raw HTML omitted --></p>
<ol>
<li>服务启动后 gRPC 客户端向注册中心获取后端服务列表</li>
<li>客户端实例化负载均衡策略</li>
<li>负载均衡器（Balancer）为每一个后端地址创建一个子连接（SubConn）</li>
<li>当要发起 RPC 请求的时候，负载均衡器就会选择当前最匹配的子连接来进行 RCP 调用</li>
</ol>
<h2 id="2-问题">2. 问题</h2>
<p>带着问题来看源码，收获会更多：</p>
<ul>
<li>Balancer 如何接收来自 Resolver 解析出来的地址？</li>
<li>与这些地址的连接是在哪建立的？</li>
<li>如何选择每次调用适合的连接？</li>
</ul>
<p><a href="https://github.com/grpc/proposal/blob/master/L9-go-resolver-balancer-API.md">L9-go-resolver-balancer-API</a>这篇文章中给出了 resolver-balancer 的设计理念，并且给出了官方架构图：</p>
<p><img src="https://blog-wero.oss-cn-shanghai.aliyuncs.com/img/resolver-balancer-arch.png" alt="resolver-balancer"></p>
<p>图中，我们可以看见 Balancer 位于 gRPC 的右方，并且 Resolver 与 Balancer 没有耦合在一起，而是采用接口隔离加 Builder 和Wrapper 设计模式。其中，Balancer 负责与后端服务器建立连接，并且创建 Picker 来执行负载均衡的逻辑。</p>
<h2 id="3-一切都要从-resolver-说起">3. 一切都要从 Resolver 说起</h2>
<p>上文，我们提到 Resolver 在解析到后端服务器列表之后会通过 <code>resolver.ClientConn.UpdateState(state)</code>来通知 gRPC 后端地址有更新，对应上图的左边 <code>Addr Updates</code>。代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// ccResolverWrapper 可以看做是 Resolver 的代理，并且实现了resolver.ClientConn接口
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ccResolverWrapper</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">cc</span>         <span class="o">*</span><span class="nx">ClientConn</span>
	<span class="nx">resolverMu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
	<span class="nx">resolver</span>   <span class="nx">resolver</span><span class="p">.</span><span class="nx">Resolver</span>
	<span class="nx">done</span>       <span class="o">*</span><span class="nx">grpcsync</span><span class="p">.</span><span class="nx">Event</span>
	<span class="nx">curState</span>   <span class="nx">resolver</span><span class="p">.</span><span class="nx">State</span>

	<span class="nx">pollingMu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
	<span class="nx">polling</span>   <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">ccr</span> <span class="o">*</span><span class="nx">ccResolverWrapper</span><span class="p">)</span> <span class="nf">UpdateState</span><span class="p">(</span><span class="nx">s</span> <span class="nx">resolver</span><span class="p">.</span><span class="nx">State</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">ccr</span><span class="p">.</span><span class="nx">done</span><span class="p">.</span><span class="nf">HasFired</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="o">...</span>
	<span class="c1">// 更新地址池
</span><span class="c1"></span>	<span class="nx">ccr</span><span class="p">.</span><span class="nx">curState</span> <span class="p">=</span> <span class="nx">s</span>
	<span class="nx">ccr</span><span class="p">.</span><span class="nf">poll</span><span class="p">(</span><span class="nx">ccr</span><span class="p">.</span><span class="nx">cc</span><span class="p">.</span><span class="nf">updateResolverState</span><span class="p">(</span><span class="nx">ccr</span><span class="p">.</span><span class="nx">curState</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div><p>可见最终会调用 <code>ClientConn.updateResolverState(ccr.curState, nil)</code> 方法，在这个方法里面，gRPC 会处理 Balancer 的逻辑。</p>
<p>这里需要梳理一下：</p>
<ul>
<li>ccResolverWrapper 实现了 <code>resolver.ClientConn</code> 接口</li>
<li>ccResolverWrapper 中的 cc 是 <code>grpc.ClientConn</code> 结构体</li>
<li>当在 Resolver 中调用  <code>resolver.ClientConn.UpdateState(state)</code> 的时候，便最终会调用 <code>ClientConn.updateResolverState(ccr.curState, nil)</code></li>
</ul>
<p>以 dnsResolver 为例，调用链如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">dnsResovler.watcher --&gt; ccResolverWrapper.UpdateState --&gt; ClientConn.updateResolverState
--&gt;  cc.balancerWrapper.updateClientConnState
</code></pre></div><h3 id="clientconnupdateresolverstate">ClientConn.updateResolverState</h3>
<p>updateResolverState 会与 Balancer 模块进行交互：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">cc</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">)</span> <span class="nf">updateResolverState</span><span class="p">(</span><span class="nx">s</span> <span class="nx">resolver</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">firstResolveEvent</span><span class="p">.</span><span class="nf">Fire</span><span class="p">()</span>
	<span class="nx">cc</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="c1">// Check if the ClientConn is already closed. Some fields (e.g.
</span><span class="c1"></span>	<span class="c1">// balancerWrapper) are set to nil when closing the ClientConn, and could
</span><span class="c1"></span>	<span class="c1">// cause nil pointer panic if we don&#39;t have this check.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">conns</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">cc</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// May need to apply the initial service config in case the resolver
</span><span class="c1"></span>		<span class="c1">// doesn&#39;t support service configs, or doesn&#39;t provide a service config
</span><span class="c1"></span>		<span class="c1">// with the new addresses.
</span><span class="c1"></span>		<span class="nx">cc</span><span class="p">.</span><span class="nf">maybeApplyDefaultServiceConfig</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span>

		<span class="k">if</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">balancerWrapper</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">cc</span><span class="p">.</span><span class="nx">balancerWrapper</span><span class="p">.</span><span class="nf">resolverError</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="c1">// No addresses are valid with err set; return early.
</span><span class="c1"></span>		<span class="nx">cc</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
		<span class="k">return</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">ErrBadResolverState</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">ret</span> <span class="kt">error</span>
	<span class="c1">// 如果禁用服务配置或者服务配置为空, 则可能使用默认配置
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">disableServiceConfig</span> <span class="o">||</span> <span class="nx">s</span><span class="p">.</span><span class="nx">ServiceConfig</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="c1">// A
</span><span class="c1"></span>		<span class="nx">cc</span><span class="p">.</span><span class="nf">maybeApplyDefaultServiceConfig</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Addresses</span><span class="p">)</span>
		<span class="c1">// TODO: do we need to apply a failing LB policy if there is no
</span><span class="c1"></span>		<span class="c1">// default, per the error handling design?
</span><span class="c1"></span>	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// B
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">sc</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">ServiceConfig</span><span class="p">.</span><span class="nx">Config</span><span class="p">.(</span><span class="o">*</span><span class="nx">ServiceConfig</span><span class="p">);</span> <span class="nx">s</span><span class="p">.</span><span class="nx">ServiceConfig</span><span class="p">.</span><span class="nx">Err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">ok</span> <span class="p">{</span>
			<span class="nx">cc</span><span class="p">.</span><span class="nf">applyServiceConfigAndBalancer</span><span class="p">(</span><span class="nx">sc</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Addresses</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">// 配置不正确
</span><span class="c1"></span>			<span class="nx">ret</span> <span class="p">=</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">ErrBadResolverState</span>
			<span class="k">if</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">balancerWrapper</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
				<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">ServiceConfig</span><span class="p">.</span><span class="nx">Err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="nx">err</span> <span class="p">=</span> <span class="nx">status</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="nx">codes</span><span class="p">.</span><span class="nx">Unavailable</span><span class="p">,</span> <span class="s">&#34;error parsing service config: %v&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">ServiceConfig</span><span class="p">.</span><span class="nx">Err</span><span class="p">)</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="nx">err</span> <span class="p">=</span> <span class="nx">status</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="nx">codes</span><span class="p">.</span><span class="nx">Unavailable</span><span class="p">,</span> <span class="s">&#34;illegal service config type: %T&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">ServiceConfig</span><span class="p">.</span><span class="nx">Config</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="nx">cc</span><span class="p">.</span><span class="nx">blockingpicker</span><span class="p">.</span><span class="nf">updatePicker</span><span class="p">(</span><span class="nx">base</span><span class="p">.</span><span class="nf">NewErrPicker</span><span class="p">(</span><span class="nx">err</span><span class="p">))</span>
				<span class="nx">cc</span><span class="p">.</span><span class="nx">csMgr</span><span class="p">.</span><span class="nf">updateState</span><span class="p">(</span><span class="nx">connectivity</span><span class="p">.</span><span class="nx">TransientFailure</span><span class="p">)</span>
				<span class="nx">cc</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
				<span class="k">return</span> <span class="nx">ret</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">balCfg</span> <span class="nx">serviceconfig</span><span class="p">.</span><span class="nx">LoadBalancingConfig</span>
	<span class="c1">// 优先使用客户端配置的负载均衡策略
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">balancerBuilder</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">sc</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">sc</span><span class="p">.</span><span class="nx">lbConfig</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">balCfg</span> <span class="p">=</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">sc</span><span class="p">.</span><span class="nx">lbConfig</span><span class="p">.</span><span class="nx">cfg</span>
	<span class="p">}</span>

	<span class="nx">cbn</span> <span class="o">:=</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">curBalancerName</span>
	<span class="nx">bw</span> <span class="o">:=</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">balancerWrapper</span>
	<span class="nx">cc</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="c1">// 如果负载的负载均衡策略不是 grpclb, 就剔除所有类型是 grpclb 的地址
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">cbn</span> <span class="o">!=</span> <span class="nx">grpclbName</span> <span class="p">{</span>
		<span class="c1">// Filter any grpclb addresses since we don&#39;t have the grpclb balancer.
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Addresses</span><span class="p">);</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Addresses</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Type</span> <span class="o">==</span> <span class="nx">resolver</span><span class="p">.</span><span class="nx">GRPCLB</span> <span class="p">{</span>
				<span class="nb">copy</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Addresses</span><span class="p">[</span><span class="nx">i</span><span class="p">:],</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Addresses</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span>
				<span class="nx">s</span><span class="p">.</span><span class="nx">Addresses</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Addresses</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">Addresses</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="nx">i</span><span class="o">++</span>
		<span class="p">}</span>
	<span class="p">}</span>
 	<span class="c1">// 调用负载均衡策略更新连接状态
</span><span class="c1"></span>	<span class="nx">uccsErr</span> <span class="o">:=</span> <span class="nx">bw</span><span class="p">.</span><span class="nf">updateClientConnState</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">balancer</span><span class="p">.</span><span class="nx">ClientConnState</span><span class="p">{</span><span class="nx">ResolverState</span><span class="p">:</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">BalancerConfig</span><span class="p">:</span> <span class="nx">balCfg</span><span class="p">})</span>
	<span class="k">if</span> <span class="nx">ret</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">ret</span> <span class="p">=</span> <span class="nx">uccsErr</span> <span class="c1">// prefer ErrBadResolver state since any other error is
</span><span class="c1"></span>		<span class="c1">// currently meaningless to the caller.
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">ret</span>
<span class="p">}</span>
</code></pre></div><p>一般情况下，我们都会进入 A 代码块（使用默认配置）：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">cc</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">)</span> <span class="nf">maybeApplyDefaultServiceConfig</span><span class="p">(</span><span class="nx">addrs</span> <span class="p">[]</span><span class="nx">resolver</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">sc</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">cc</span><span class="p">.</span><span class="nf">applyServiceConfigAndBalancer</span><span class="p">(</span><span class="nx">cc</span><span class="p">.</span><span class="nx">sc</span><span class="p">,</span> <span class="nx">addrs</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">defaultServiceConfig</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">cc</span><span class="p">.</span><span class="nf">applyServiceConfigAndBalancer</span><span class="p">(</span><span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">defaultServiceConfig</span><span class="p">,</span> <span class="nx">addrs</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// 
</span><span class="c1"></span>		<span class="nx">cc</span><span class="p">.</span><span class="nf">applyServiceConfigAndBalancer</span><span class="p">(</span><span class="nx">emptyServiceConfig</span><span class="p">,</span> <span class="nx">addrs</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>当我们未指定配置的时候，会传入 <code>emptyServiceConfig</code> 空的配置,  然后调用 <code>ClientConn.applyServiceConfigAndBalancer</code>：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">cc</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">)</span> <span class="nf">applyServiceConfigAndBalancer</span><span class="p">(</span><span class="nx">sc</span> <span class="o">*</span><span class="nx">ServiceConfig</span><span class="p">,</span> <span class="nx">addrs</span> <span class="p">[]</span><span class="nx">resolver</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">sc</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// should never reach here.
</span><span class="c1"></span>		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">// 可能是 emptyServiceConfig
</span><span class="c1"></span>	<span class="nx">cc</span><span class="p">.</span><span class="nx">sc</span> <span class="p">=</span> <span class="nx">sc</span>

	<span class="k">if</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">sc</span><span class="p">.</span><span class="nx">retryThrottling</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">newThrottler</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">retryThrottler</span><span class="p">{</span>
			<span class="nx">tokens</span><span class="p">:</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">sc</span><span class="p">.</span><span class="nx">retryThrottling</span><span class="p">.</span><span class="nx">MaxTokens</span><span class="p">,</span>
			<span class="nx">max</span><span class="p">:</span>    <span class="nx">cc</span><span class="p">.</span><span class="nx">sc</span><span class="p">.</span><span class="nx">retryThrottling</span><span class="p">.</span><span class="nx">MaxTokens</span><span class="p">,</span>
			<span class="nx">thresh</span><span class="p">:</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">sc</span><span class="p">.</span><span class="nx">retryThrottling</span><span class="p">.</span><span class="nx">MaxTokens</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
			<span class="nx">ratio</span><span class="p">:</span>  <span class="nx">cc</span><span class="p">.</span><span class="nx">sc</span><span class="p">.</span><span class="nx">retryThrottling</span><span class="p">.</span><span class="nx">TokenRatio</span><span class="p">,</span>
		<span class="p">}</span>
		<span class="nx">cc</span><span class="p">.</span><span class="nx">retryThrottler</span><span class="p">.</span><span class="nf">Store</span><span class="p">(</span><span class="nx">newThrottler</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">cc</span><span class="p">.</span><span class="nx">retryThrottler</span><span class="p">.</span><span class="nf">Store</span><span class="p">((</span><span class="o">*</span><span class="nx">retryThrottler</span><span class="p">)(</span><span class="kc">nil</span><span class="p">))</span>
	<span class="p">}</span>

  <span class="c1">// 如果没有指定 balancerBuilder, 就需要先获取一个 builder, 一般情况下都会指定
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">balancerBuilder</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// Only look at balancer types and switch balancer if balancer dial
</span><span class="c1"></span>		<span class="c1">// option is not set.
</span><span class="c1"></span>		<span class="kd">var</span> <span class="nx">newBalancerName</span> <span class="kt">string</span>
		<span class="k">if</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">sc</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">sc</span><span class="p">.</span><span class="nx">lbConfig</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="c1">// 1. 使用 ServiceConfig 指定的 Builder
</span><span class="c1"></span>			<span class="nx">newBalancerName</span> <span class="p">=</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">sc</span><span class="p">.</span><span class="nx">lbConfig</span><span class="p">.</span><span class="nx">name</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="kd">var</span> <span class="nx">isGRPCLB</span> <span class="kt">bool</span>
			<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">a</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">addrs</span> <span class="p">{</span>
				<span class="k">if</span> <span class="nx">a</span><span class="p">.</span><span class="nx">Type</span> <span class="o">==</span> <span class="nx">resolver</span><span class="p">.</span><span class="nx">GRPCLB</span> <span class="p">{</span>
					<span class="nx">isGRPCLB</span> <span class="p">=</span> <span class="kc">true</span>
					<span class="k">break</span>
				<span class="p">}</span>
			<span class="p">}</span>
      <span class="c1">// 2. 如果至少有一个地址的类型是 GRPCLB, 那么使用 GRPCLB
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">isGRPCLB</span> <span class="p">{</span>
				<span class="nx">newBalancerName</span> <span class="p">=</span> <span class="nx">grpclbName</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">sc</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">sc</span><span class="p">.</span><span class="nx">LB</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="c1">// 3. 使用 WithBalancer 提供的 builder
</span><span class="c1"></span>				<span class="nx">newBalancerName</span> <span class="p">=</span> <span class="o">*</span><span class="nx">cc</span><span class="p">.</span><span class="nx">sc</span><span class="p">.</span><span class="nx">LB</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// 4. 使用 pick_first
</span><span class="c1"></span>				<span class="nx">newBalancerName</span> <span class="p">=</span> <span class="nx">PickFirstBalancerName</span>
			<span class="p">}</span>
		<span class="p">}</span>
    <span class="c1">// 切换负载均衡策略
</span><span class="c1"></span>		<span class="nx">cc</span><span class="p">.</span><span class="nf">switchBalancer</span><span class="p">(</span><span class="nx">newBalancerName</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">balancerWrapper</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// Balancer dial option was set, and this is the first time handling
</span><span class="c1"></span>		<span class="c1">// resolved addresses. Build a balancer with dopts.balancerBuilder.
</span><span class="c1"></span>		<span class="nx">cc</span><span class="p">.</span><span class="nx">curBalancerName</span> <span class="p">=</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">balancerBuilder</span><span class="p">.</span><span class="nf">Name</span><span class="p">()</span>
		<span class="nx">cc</span><span class="p">.</span><span class="nx">balancerWrapper</span> <span class="p">=</span> <span class="nf">newCCBalancerWrapper</span><span class="p">(</span><span class="nx">cc</span><span class="p">,</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">balancerBuilder</span><span class="p">,</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">balancerBuildOpts</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>从上面代码可以看出 ClientConn 会通过服务配置选择对应的 Balancer：</p>
<ol>
<li>
<p>优先使用客户端配置的负载均衡策略</p>
</li>
<li>
<p>如果客户端没有指定负载均衡策略，那么会通过服务配置来决定使用什么负载均衡策略，选择规则如下：</p>
<ol>
<li>
<p>使用 ServiceConfig 指定的负载均衡策略</p>
</li>
<li>
<p>如果至少有一个地址的类型是 GRPCLB, 那么使用 GRPCLB</p>
</li>
<li>
<p>使用 WithBalancer 提供的负载均衡策略， 不过这个选择已经被优化掉了，可以查看字段 LB 上面的注释：</p>
<blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// LB is the load balancer the service providers recommends. The balancer
</span><span class="c1">// specified via grpc.WithBalancerName will override this.  This is deprecated;
</span><span class="c1">// lbConfigs is preferred.  If lbConfig and LB are both present, lbConfig
</span><span class="c1">// will be used.
</span><span class="c1"></span><span class="nx">LB</span> <span class="o">*</span><span class="kt">string</span>
</code></pre></div></blockquote>
<p>说明，如果使用了 WithBalancerName 来指定负载均衡策略，那么会覆盖掉这个选项，即会<strong>优先使用客户端配置的负载均衡策略</strong></p>
</li>
<li>
<p>使用 pick_first 负载均衡策略</p>
</li>
</ol>
</li>
</ol>
<p>在完成负载均衡策略的初始化或切换之后，会调用<code>bw.updateClientConnState(&amp;balancer.ClientConnState{ResolverState: s, BalancerConfig: balCfg})</code> 来更新连接的状态（bw 就是 balancerWrapper），这个方法在后面会解析。</p>
<h2 id="4-balancer-分析">4. Balancer 分析</h2>
<p>Balancer 包的结构跟 Resolver 的包结构类似，都是采用 Builder + Wrapper 设计模式相结合，使用者只需要实现自己的 Balancer，然后再以插件的形式注册到 gRPC 中就可以与其他模块配合使用。</p>
<h3 id="newccbalancerwrapper">newCCBalancerWrapper</h3>
<p>新建一个 ccBalancerWrapper，并且和 ccResolverWrapper 一样，存储到 <code>ClientConn</code> 的 <code>balancerWrapper</code> 中：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">newCCBalancerWrapper</span><span class="p">(</span><span class="nx">cc</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">,</span> <span class="nx">b</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">Builder</span><span class="p">,</span> <span class="nx">bopts</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">BuildOptions</span><span class="p">)</span> <span class="o">*</span><span class="nx">ccBalancerWrapper</span> <span class="p">{</span>
	<span class="c1">// 初始化实例
</span><span class="c1"></span>  <span class="nx">ccb</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">ccBalancerWrapper</span><span class="p">{</span>
		<span class="nx">cc</span><span class="p">:</span>       <span class="nx">cc</span><span class="p">,</span>
		<span class="nx">scBuffer</span><span class="p">:</span> <span class="nx">buffer</span><span class="p">.</span><span class="nf">NewUnbounded</span><span class="p">(),</span>
		<span class="nx">done</span><span class="p">:</span>     <span class="nx">grpcsync</span><span class="p">.</span><span class="nf">NewEvent</span><span class="p">(),</span>
		<span class="nx">subConns</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="o">*</span><span class="nx">acBalancerWrapper</span><span class="p">]</span><span class="kd">struct</span><span class="p">{}),</span>
	<span class="p">}</span>
  <span class="c1">// 启动协程监听
</span><span class="c1"></span>	<span class="k">go</span> <span class="nx">ccb</span><span class="p">.</span><span class="nf">watcher</span><span class="p">()</span>
  <span class="c1">// Build 负载均衡器
</span><span class="c1"></span>	<span class="nx">ccb</span><span class="p">.</span><span class="nx">balancer</span> <span class="p">=</span> <span class="nx">b</span><span class="p">.</span><span class="nf">Build</span><span class="p">(</span><span class="nx">ccb</span><span class="p">,</span> <span class="nx">bopts</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">ccb</span>
<span class="p">}</span>
</code></pre></div><h3 id="ccbalancerwrapperwatcher">ccBalancerWrapper.watcher</h3>
<p>在创建 ccBalancerWrapper 会启动一个goroutine 来执行 watcher 方法，那 <em>watcher</em> 的作用是什么呢？</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// watcher balancer functions sequentially, so the balancer can be implemented
</span><span class="c1">// lock-free.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">ccb</span> <span class="o">*</span><span class="nx">ccBalancerWrapper</span><span class="p">)</span> <span class="nf">watcher</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">t</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ccb</span><span class="p">.</span><span class="nx">scBuffer</span><span class="p">.</span><span class="nf">Get</span><span class="p">():</span>
			<span class="nx">ccb</span><span class="p">.</span><span class="nx">scBuffer</span><span class="p">.</span><span class="nf">Load</span><span class="p">()</span>
			<span class="k">if</span> <span class="nx">ccb</span><span class="p">.</span><span class="nx">done</span><span class="p">.</span><span class="nf">HasFired</span><span class="p">()</span> <span class="p">{</span>
				<span class="k">break</span>
			<span class="p">}</span>
			<span class="nx">ccb</span><span class="p">.</span><span class="nx">balancerMu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
			<span class="nx">su</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.(</span><span class="o">*</span><span class="nx">scStateUpdate</span><span class="p">)</span>
			<span class="nx">ccb</span><span class="p">.</span><span class="nx">balancer</span><span class="p">.</span><span class="nf">UpdateSubConnState</span><span class="p">(</span><span class="nx">su</span><span class="p">.</span><span class="nx">sc</span><span class="p">,</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">SubConnState</span><span class="p">{</span><span class="nx">ConnectivityState</span><span class="p">:</span> <span class="nx">su</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="nx">ConnectionError</span><span class="p">:</span> <span class="nx">su</span><span class="p">.</span><span class="nx">err</span><span class="p">})</span>
			<span class="nx">ccb</span><span class="p">.</span><span class="nx">balancerMu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ccb</span><span class="p">.</span><span class="nx">done</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="nx">ccb</span><span class="p">.</span><span class="nx">done</span><span class="p">.</span><span class="nf">HasFired</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">ccb</span><span class="p">.</span><span class="nx">balancer</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
			<span class="nx">ccb</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
			<span class="nx">scs</span> <span class="o">:=</span> <span class="nx">ccb</span><span class="p">.</span><span class="nx">subConns</span>
			<span class="nx">ccb</span><span class="p">.</span><span class="nx">subConns</span> <span class="p">=</span> <span class="kc">nil</span>
			<span class="nx">ccb</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
			<span class="k">for</span> <span class="nx">acbw</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">scs</span> <span class="p">{</span>
				<span class="nx">ccb</span><span class="p">.</span><span class="nx">cc</span><span class="p">.</span><span class="nf">removeAddrConn</span><span class="p">(</span><span class="nx">acbw</span><span class="p">.</span><span class="nf">getAddrConn</span><span class="p">(),</span> <span class="nx">errConnDrain</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">ccb</span><span class="p">.</span><span class="nf">UpdateState</span><span class="p">(</span><span class="nx">balancer</span><span class="p">.</span><span class="nx">State</span><span class="p">{</span><span class="nx">ConnectivityState</span><span class="p">:</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">Connecting</span><span class="p">,</span> <span class="nx">Picker</span><span class="p">:</span> <span class="kc">nil</span><span class="p">})</span>
			<span class="k">return</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>从代码的注释中，我们可以知道为什么要专门启动一个 goroutine 来执行 watcher 方法：为了监听服务器地址的更新和状态变化，并且让 balancer 实现无锁更新，后文会详细讲解。</p>
<h3 id="balancerbuilder">balancer.Builder</h3>
<p>和 Resolver 一样，在实现 Balancer 的组件的同时也要实现一个 Builder，用来构建 Balancer 实例。以 <code>grpclb</code> 负载均衡器为例：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">lbBuilder</span><span class="p">)</span> <span class="nf">Build</span><span class="p">(</span><span class="nx">cc</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">ClientConn</span><span class="p">,</span> <span class="nx">opt</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">BuildOptions</span><span class="p">)</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">Balancer</span> <span class="p">{</span>
	<span class="c1">// This generates a manual resolver builder with a fixed scheme. This
</span><span class="c1"></span>	<span class="c1">// scheme will be used to dial to remote LB, so we can send filtered
</span><span class="c1"></span>	<span class="c1">// address updates to remote LB ClientConn using this manual resolver.
</span><span class="c1"></span>  <span class="c1">// grpclb 内部的 resolver，有特殊用途
</span><span class="c1"></span>	<span class="nx">r</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">lbManualResolver</span><span class="p">{</span><span class="nx">scheme</span><span class="p">:</span> <span class="s">&#34;grpclb-internal&#34;</span><span class="p">,</span> <span class="nx">ccb</span><span class="p">:</span> <span class="nx">cc</span><span class="p">}</span>

	<span class="nx">lb</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">lbBalancer</span><span class="p">{</span>
    <span class="c1">// 有缓存功能的 ClientConn wrapper
</span><span class="c1"></span>		<span class="nx">cc</span><span class="p">:</span>              <span class="nf">newLBCacheClientConn</span><span class="p">(</span><span class="nx">cc</span><span class="p">),</span>
		<span class="nx">target</span><span class="p">:</span>          <span class="nx">opt</span><span class="p">.</span><span class="nx">Target</span><span class="p">.</span><span class="nx">Endpoint</span><span class="p">,</span>
		<span class="nx">opt</span><span class="p">:</span>             <span class="nx">opt</span><span class="p">,</span>
		<span class="nx">fallbackTimeout</span><span class="p">:</span> <span class="nx">b</span><span class="p">.</span><span class="nx">fallbackTimeout</span><span class="p">,</span>
		<span class="nx">doneCh</span><span class="p">:</span>          <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}),</span>

		<span class="nx">manualResolver</span><span class="p">:</span> <span class="nx">r</span><span class="p">,</span>
		<span class="nx">subConns</span><span class="p">:</span>       <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">resolver</span><span class="p">.</span><span class="nx">Address</span><span class="p">]</span><span class="nx">balancer</span><span class="p">.</span><span class="nx">SubConn</span><span class="p">),</span>
		<span class="nx">scStates</span><span class="p">:</span>       <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">balancer</span><span class="p">.</span><span class="nx">SubConn</span><span class="p">]</span><span class="nx">connectivity</span><span class="p">.</span><span class="nx">State</span><span class="p">),</span>
    <span class="c1">// 初始化 picker
</span><span class="c1"></span>		<span class="nx">picker</span><span class="p">:</span>         <span class="o">&amp;</span><span class="nx">errPicker</span><span class="p">{</span><span class="nx">err</span><span class="p">:</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">ErrNoSubConnAvailable</span><span class="p">},</span>
		<span class="nx">clientStats</span><span class="p">:</span>    <span class="nf">newRPCStats</span><span class="p">(),</span>
		<span class="nx">backoff</span><span class="p">:</span>        <span class="nx">backoff</span><span class="p">.</span><span class="nx">DefaultExponential</span><span class="p">,</span> <span class="c1">// TODO: make backoff configurable.
</span><span class="c1"></span>	<span class="p">}</span>

	<span class="o">...</span>

	<span class="k">return</span> <span class="nx">lb</span>
<span class="p">}</span>
</code></pre></div><h3 id="balancer-接口">Balancer 接口</h3>
<p>我们再来看看 Balancer 都有哪些方法：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Balancer takes input from gRPC, manages SubConns, and collects and aggregates
</span><span class="c1">// the connectivity states.
</span><span class="c1">//
</span><span class="c1">// It also generates and updates the Picker used by gRPC to pick SubConns for RPCs.
</span><span class="c1">//
</span><span class="c1">// UpdateClientConnState, ResolverError, UpdateSubConnState, and Close are
</span><span class="c1">// guaranteed to be called synchronously from the same goroutine.  There&#39;s no
</span><span class="c1">// guarantee on picker.Pick, it may be called anytime.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Balancer</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="c1">// 当 ClientConn 的状态发生变化时, gRPC 会调用这个方法
</span><span class="c1"></span>	<span class="c1">// 如果返回的错误是ErrBadResolverState, ClientConn 会立即以指数退避的方式调用 Resolver 的 ResolveNow 方法,
</span><span class="c1"></span>	<span class="c1">// 直到调用 UpdateClientConnState 返回 nil
</span><span class="c1"></span>	<span class="nf">UpdateClientConnState</span><span class="p">(</span><span class="nx">ClientConnState</span><span class="p">)</span> <span class="kt">error</span>
	<span class="c1">// 当 resolver 解析发生错误时, gRPC 会调用这个方法
</span><span class="c1"></span>	<span class="nf">ResolverError</span><span class="p">(</span><span class="kt">error</span><span class="p">)</span>
	<span class="c1">// 当子连接状态发生变化时，gRPC 会调用这个方法
</span><span class="c1"></span>	<span class="nf">UpdateSubConnState</span><span class="p">(</span><span class="nx">SubConn</span><span class="p">,</span> <span class="nx">SubConnState</span><span class="p">)</span>
	
	<span class="nf">Close</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><h3 id="lbbalancerupdateclientconnstate">lbBalancer.UpdateClientConnState</h3>
<p>UpdateClientConnState 是如何被调用的呢？原来是通过前文提到的 <code>bw.updateClientConnState</code> 来间接调用的，由 Resolver 到 ClientConn，再到 Balancer，在下面的调用链中一览无余：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">ccResolverWrapper</span><span class="p">.</span><span class="nx">UpdateState</span> <span class="o">-</span><span class="p">&gt;</span> <span class="nx">ClientConn</span><span class="p">.</span><span class="nx">updateResolverState</span> <span class="o">-</span><span class="p">&gt;</span> <span class="nx">ccBalancerWrapper</span><span class="p">.</span><span class="nx">updateClientConnState</span> <span class="o">-</span><span class="p">&gt;</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">Balancer</span><span class="p">.</span><span class="nx">UpdateClientConnState</span>
</code></pre></div><p>上面的调用关系中不涉及到具体的实现，我们来看看 <code>lbBalancer.UpdateClientConnState</code> 是如何实现的：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">lb</span> <span class="o">*</span><span class="nx">lbBalancer</span><span class="p">)</span> <span class="nf">UpdateClientConnState</span><span class="p">(</span><span class="nx">ccs</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">ClientConnState</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">logger</span><span class="p">.</span><span class="nf">V</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">logger</span><span class="p">.</span><span class="nf">Infof</span><span class="p">(</span><span class="s">&#34;lbBalancer: UpdateClientConnState: %+v&#34;</span><span class="p">,</span> <span class="nx">ccs</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 处理 balancer 配置
</span><span class="c1"></span>	<span class="nx">gc</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">ccs</span><span class="p">.</span><span class="nx">BalancerConfig</span><span class="p">.(</span><span class="o">*</span><span class="nx">grpclbServiceConfig</span><span class="p">)</span>
	<span class="nx">lb</span><span class="p">.</span><span class="nf">handleServiceConfig</span><span class="p">(</span><span class="nx">gc</span><span class="p">)</span>

	<span class="nx">addrs</span> <span class="o">:=</span> <span class="nx">ccs</span><span class="p">.</span><span class="nx">ResolverState</span><span class="p">.</span><span class="nx">Addresses</span>

	<span class="c1">// 区分地址的类型, 并且把 GRPCLB 类型的地址改为了 Backend
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">remoteBalancerAddrs</span><span class="p">,</span> <span class="nx">backendAddrs</span> <span class="p">[]</span><span class="nx">resolver</span><span class="p">.</span><span class="nx">Address</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">a</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">addrs</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">a</span><span class="p">.</span><span class="nx">Type</span> <span class="o">==</span> <span class="nx">resolver</span><span class="p">.</span><span class="nx">GRPCLB</span> <span class="p">{</span>
			<span class="nx">a</span><span class="p">.</span><span class="nx">Type</span> <span class="p">=</span> <span class="nx">resolver</span><span class="p">.</span><span class="nx">Backend</span>
			<span class="nx">remoteBalancerAddrs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">remoteBalancerAddrs</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">backendAddrs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">backendAddrs</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">sd</span> <span class="o">:=</span> <span class="nx">grpclbstate</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">ccs</span><span class="p">.</span><span class="nx">ResolverState</span><span class="p">);</span> <span class="nx">sd</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// Override any balancer addresses provided via
</span><span class="c1"></span>		<span class="c1">// ccs.ResolverState.Addresses.
</span><span class="c1"></span>		<span class="nx">remoteBalancerAddrs</span> <span class="p">=</span> <span class="nx">sd</span><span class="p">.</span><span class="nx">BalancerAddresses</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">backendAddrs</span><span class="p">)</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="nx">remoteBalancerAddrs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// There should be at least one address, either grpclb server or
</span><span class="c1"></span>		<span class="c1">// fallback. Empty address is not valid.
</span><span class="c1"></span>		<span class="k">return</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">ErrBadResolverState</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">remoteBalancerAddrs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">lb</span><span class="p">.</span><span class="nx">ccRemoteLB</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">lb</span><span class="p">.</span><span class="nx">ccRemoteLB</span><span class="p">.</span><span class="nb">close</span><span class="p">()</span>
			<span class="nx">lb</span><span class="p">.</span><span class="nx">ccRemoteLB</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">lb</span><span class="p">.</span><span class="nx">ccRemoteLB</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// 第一次收到解析到的 remoteBalancerAddrs 地址, 建立与远程负载均衡器的连接
</span><span class="c1"></span>		<span class="nx">lb</span><span class="p">.</span><span class="nf">newRemoteBalancerCCWrapper</span><span class="p">()</span>
		<span class="c1">// Start the fallback goroutine.
</span><span class="c1"></span>		<span class="k">go</span> <span class="nx">lb</span><span class="p">.</span><span class="nf">fallbackToBackendsAfter</span><span class="p">(</span><span class="nx">lb</span><span class="p">.</span><span class="nx">fallbackTimeout</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">lb</span><span class="p">.</span><span class="nx">ccRemoteLB</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// cc to remote balancers uses lb.manualResolver. Send the updated remote
</span><span class="c1"></span>		<span class="c1">// balancer addresses to it through manualResolver.
</span><span class="c1"></span>		<span class="nx">lb</span><span class="p">.</span><span class="nx">manualResolver</span><span class="p">.</span><span class="nf">UpdateState</span><span class="p">(</span><span class="nx">resolver</span><span class="p">.</span><span class="nx">State</span><span class="p">{</span><span class="nx">Addresses</span><span class="p">:</span> <span class="nx">remoteBalancerAddrs</span><span class="p">})</span>
	<span class="p">}</span>

	<span class="nx">lb</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="nx">lb</span><span class="p">.</span><span class="nx">resolvedBackendAddrs</span> <span class="p">=</span> <span class="nx">backendAddrs</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">remoteBalancerAddrs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">lb</span><span class="p">.</span><span class="nx">inFallback</span> <span class="p">{</span>
		<span class="c1">// If there&#39;s no remote balancer address in ClientConn update, grpclb
</span><span class="c1"></span>		<span class="c1">// enters fallback mode immediately.
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// If a new update is received while grpclb is in fallback, update the
</span><span class="c1"></span>		<span class="c1">// list of backends being used to the new fallback backends.
</span><span class="c1"></span>		<span class="nx">lb</span><span class="p">.</span><span class="nf">refreshSubConns</span><span class="p">(</span><span class="nx">lb</span><span class="p">.</span><span class="nx">resolvedBackendAddrs</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">lb</span><span class="p">.</span><span class="nx">usePickFirst</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">lb</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>lbBalancer 把地址分为两种类型：<code>resolver.GRPCLB</code>，<code>resolver.Backend</code>。当 dnsResolver 传过来的地址列表中有 resolver.GRPCLB，lbBalancer 会与<code>resolver.GRPCLB</code>的负载均衡器建立连接以获取真正服务的地址。不过，我们在这里并不做深究。</p>
<h3 id="lbbalancernewremotebalancerccwrapper">lbBalancer.newRemoteBalancerCCWrapper</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">lb</span> <span class="o">*</span><span class="nx">lbBalancer</span><span class="p">)</span> <span class="nf">refreshSubConns</span><span class="p">(</span><span class="nx">backendAddrs</span> <span class="p">[]</span><span class="nx">resolver</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">fallback</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">pickFirst</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">opts</span> <span class="o">:=</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">NewSubConnOptions</span><span class="p">{}</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">fallback</span> <span class="p">{</span>
		<span class="nx">opts</span><span class="p">.</span><span class="nx">CredsBundle</span> <span class="p">=</span> <span class="nx">lb</span><span class="p">.</span><span class="nx">grpclbBackendCreds</span>
	<span class="p">}</span>

	<span class="c1">// 更新后端地址
</span><span class="c1"></span>	<span class="nx">lb</span><span class="p">.</span><span class="nx">backendAddrs</span> <span class="p">=</span> <span class="nx">backendAddrs</span>
	<span class="nx">lb</span><span class="p">.</span><span class="nx">backendAddrsWithoutMetadata</span> <span class="p">=</span> <span class="kc">nil</span>

	<span class="nx">fallbackModeChanged</span> <span class="o">:=</span> <span class="nx">lb</span><span class="p">.</span><span class="nx">inFallback</span> <span class="o">!=</span> <span class="nx">fallback</span>
	<span class="nx">lb</span><span class="p">.</span><span class="nx">inFallback</span> <span class="p">=</span> <span class="nx">fallback</span>
	<span class="k">if</span> <span class="nx">fallbackModeChanged</span> <span class="o">&amp;&amp;</span> <span class="nx">lb</span><span class="p">.</span><span class="nx">inFallback</span> <span class="p">{</span>
		<span class="c1">// Clear previous received list when entering fallback, so if the server
</span><span class="c1"></span>		<span class="c1">// comes back and sends the same list again, the new addresses will be
</span><span class="c1"></span>		<span class="c1">// used.
</span><span class="c1"></span>		<span class="nx">lb</span><span class="p">.</span><span class="nx">fullServerList</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="p">}</span>

	<span class="c1">// 判断选取策略是否变化，获取第一个可用连接
</span><span class="c1"></span>	<span class="nx">balancingPolicyChanged</span> <span class="o">:=</span> <span class="nx">lb</span><span class="p">.</span><span class="nx">usePickFirst</span> <span class="o">!=</span> <span class="nx">pickFirst</span>
	<span class="nx">oldUsePickFirst</span> <span class="o">:=</span> <span class="nx">lb</span><span class="p">.</span><span class="nx">usePickFirst</span>
	<span class="nx">lb</span><span class="p">.</span><span class="nx">usePickFirst</span> <span class="p">=</span> <span class="nx">pickFirst</span>

	<span class="k">if</span> <span class="nx">fallbackModeChanged</span> <span class="o">||</span> <span class="nx">balancingPolicyChanged</span> <span class="p">{</span>
		<span class="c1">// 如果策略发生变化，删除所有的已经建立的连接
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">sc</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">lb</span><span class="p">.</span><span class="nx">subConns</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">oldUsePickFirst</span> <span class="p">{</span>
				<span class="c1">// If old SubConn were created for pickfirst, bypass cache and
</span><span class="c1"></span>				<span class="c1">// remove directly.
</span><span class="c1"></span>				<span class="nx">lb</span><span class="p">.</span><span class="nx">cc</span><span class="p">.</span><span class="nx">cc</span><span class="p">.</span><span class="nf">RemoveSubConn</span><span class="p">(</span><span class="nx">sc</span><span class="p">)</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="nx">lb</span><span class="p">.</span><span class="nx">cc</span><span class="p">.</span><span class="nf">RemoveSubConn</span><span class="p">(</span><span class="nx">sc</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nb">delete</span><span class="p">(</span><span class="nx">lb</span><span class="p">.</span><span class="nx">subConns</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// 使用 pickFirst 策略,只需要获取一个子连接就 ok 了
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">lb</span><span class="p">.</span><span class="nx">usePickFirst</span> <span class="p">{</span>
		<span class="kd">var</span> <span class="nx">sc</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">SubConn</span>
		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">sc</span> <span class="p">=</span> <span class="k">range</span> <span class="nx">lb</span><span class="p">.</span><span class="nx">subConns</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="c1">// 更新后端服务地址并触发连接
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">sc</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">sc</span><span class="p">.</span><span class="nf">UpdateAddresses</span><span class="p">(</span><span class="nx">backendAddrs</span><span class="p">)</span>
			<span class="nx">sc</span><span class="p">.</span><span class="nf">Connect</span><span class="p">()</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="c1">// This bypasses the cc wrapper with SubConn cache.
</span><span class="c1"></span>		<span class="c1">// 新建一个 SubConn, 并连接
</span><span class="c1"></span>		<span class="nx">sc</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">lb</span><span class="p">.</span><span class="nx">cc</span><span class="p">.</span><span class="nx">cc</span><span class="p">.</span><span class="nf">NewSubConn</span><span class="p">(</span><span class="nx">backendAddrs</span><span class="p">,</span> <span class="nx">opts</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">logger</span><span class="p">.</span><span class="nf">Warningf</span><span class="p">(</span><span class="s">&#34;grpclb: failed to create new SubConn: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
			<span class="k">return</span>
		<span class="p">}</span>
		<span class="nx">sc</span><span class="p">.</span><span class="nf">Connect</span><span class="p">()</span>
		<span class="nx">lb</span><span class="p">.</span><span class="nx">subConns</span><span class="p">[</span><span class="nx">backendAddrs</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="p">=</span> <span class="nx">sc</span>
		<span class="nx">lb</span><span class="p">.</span><span class="nx">scStates</span><span class="p">[</span><span class="nx">sc</span><span class="p">]</span> <span class="p">=</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">Idle</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="c1">// addrsSet is the set converted from backendAddrsWithoutMetadata, it&#39;s used to quick
</span><span class="c1"></span>	<span class="c1">// lookup for an address.
</span><span class="c1"></span>	<span class="nx">addrsSet</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">resolver</span><span class="p">.</span><span class="nx">Address</span><span class="p">]</span><span class="kd">struct</span><span class="p">{})</span>
	<span class="c1">// Create new SubConns.
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">addr</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">backendAddrs</span> <span class="p">{</span>
		<span class="nx">addrWithoutMD</span> <span class="o">:=</span> <span class="nx">addr</span>
		<span class="nx">addrWithoutMD</span><span class="p">.</span><span class="nx">Metadata</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="nx">addrsSet</span><span class="p">[</span><span class="nx">addrWithoutMD</span><span class="p">]</span> <span class="p">=</span> <span class="kd">struct</span><span class="p">{}{}</span>
		<span class="nx">lb</span><span class="p">.</span><span class="nx">backendAddrsWithoutMetadata</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">lb</span><span class="p">.</span><span class="nx">backendAddrsWithoutMetadata</span><span class="p">,</span> <span class="nx">addrWithoutMD</span><span class="p">)</span>

		<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">lb</span><span class="p">.</span><span class="nx">subConns</span><span class="p">[</span><span class="nx">addrWithoutMD</span><span class="p">];</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
			<span class="c1">// Use addrWithMD to create the SubConn.
</span><span class="c1"></span>			<span class="nx">sc</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">lb</span><span class="p">.</span><span class="nx">cc</span><span class="p">.</span><span class="nf">NewSubConn</span><span class="p">([]</span><span class="nx">resolver</span><span class="p">.</span><span class="nx">Address</span><span class="p">{</span><span class="nx">addr</span><span class="p">},</span> <span class="nx">opts</span><span class="p">)</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">logger</span><span class="p">.</span><span class="nf">Warningf</span><span class="p">(</span><span class="s">&#34;grpclb: failed to create new SubConn: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="nx">lb</span><span class="p">.</span><span class="nx">subConns</span><span class="p">[</span><span class="nx">addrWithoutMD</span><span class="p">]</span> <span class="p">=</span> <span class="nx">sc</span> <span class="c1">// Use the addr without MD as key for the map.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">lb</span><span class="p">.</span><span class="nx">scStates</span><span class="p">[</span><span class="nx">sc</span><span class="p">];</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
				<span class="c1">// Only set state of new sc to IDLE. The state could already be
</span><span class="c1"></span>				<span class="c1">// READY for cached SubConns.
</span><span class="c1"></span>				<span class="nx">lb</span><span class="p">.</span><span class="nx">scStates</span><span class="p">[</span><span class="nx">sc</span><span class="p">]</span> <span class="p">=</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">Idle</span>
			<span class="p">}</span>
			<span class="nx">sc</span><span class="p">.</span><span class="nf">Connect</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">sc</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">lb</span><span class="p">.</span><span class="nx">subConns</span> <span class="p">{</span>
		<span class="c1">// a was removed by resolver.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">addrsSet</span><span class="p">[</span><span class="nx">a</span><span class="p">];</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
			<span class="nx">lb</span><span class="p">.</span><span class="nx">cc</span><span class="p">.</span><span class="nf">RemoveSubConn</span><span class="p">(</span><span class="nx">sc</span><span class="p">)</span>
			<span class="nb">delete</span><span class="p">(</span><span class="nx">lb</span><span class="p">.</span><span class="nx">subConns</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span>
			<span class="c1">// Keep the state of this sc in b.scStates until sc&#39;s state becomes Shutdown.
</span><span class="c1"></span>			<span class="c1">// The entry will be deleted in UpdateSubConnState.
</span><span class="c1"></span>		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Regenerate and update picker after refreshing subconns because with
</span><span class="c1"></span>	<span class="c1">// cache, even if SubConn was newed/removed, there might be no state
</span><span class="c1"></span>	<span class="c1">// changes (the subconn will be kept in cache, not actually
</span><span class="c1"></span>	<span class="c1">// newed/removed).
</span><span class="c1"></span>	<span class="c1">// 更新 lb 的状态, 并且重新生成 Picker
</span><span class="c1"></span>	<span class="nx">lb</span><span class="p">.</span><span class="nf">updateStateAndPicker</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h3 id="lbbalancerupdatestateandpicker">lbBalancer.updateStateAndPicker</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">lb</span> <span class="o">*</span><span class="nx">lbBalancer</span><span class="p">)</span> <span class="nf">updateStateAndPicker</span><span class="p">(</span><span class="nx">forceRegeneratePicker</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">resetDrop</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">oldAggrState</span> <span class="o">:=</span> <span class="nx">lb</span><span class="p">.</span><span class="nx">state</span>
	<span class="nx">lb</span><span class="p">.</span><span class="nx">state</span> <span class="p">=</span> <span class="nx">lb</span><span class="p">.</span><span class="nf">aggregateSubConnStates</span><span class="p">()</span>
	<span class="c1">// Regenerate picker when one of the following happens:
</span><span class="c1"></span>	<span class="c1">//  - caller wants to regenerate
</span><span class="c1"></span>	<span class="c1">//  - the aggregated state changed
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">forceRegeneratePicker</span> <span class="o">||</span> <span class="p">(</span><span class="nx">lb</span><span class="p">.</span><span class="nx">state</span> <span class="o">!=</span> <span class="nx">oldAggrState</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 重新生成 picker
</span><span class="c1"></span>		<span class="nx">lb</span><span class="p">.</span><span class="nf">regeneratePicker</span><span class="p">(</span><span class="nx">resetDrop</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">lb</span><span class="p">.</span><span class="nx">cc</span><span class="p">.</span><span class="nf">UpdateState</span><span class="p">(</span><span class="nx">balancer</span><span class="p">.</span><span class="nx">State</span><span class="p">{</span><span class="nx">ConnectivityState</span><span class="p">:</span> <span class="nx">lb</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="nx">Picker</span><span class="p">:</span> <span class="nx">lb</span><span class="p">.</span><span class="nx">picker</span><span class="p">})</span>
<span class="p">}</span>
</code></pre></div><h3 id="lbbalancerregeneratepicker">lbBalancer.regeneratePicker</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">lb</span> <span class="o">*</span><span class="nx">lbBalancer</span><span class="p">)</span> <span class="nf">regeneratePicker</span><span class="p">(</span><span class="nx">resetDrop</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 创建 errpicker
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">lb</span><span class="p">.</span><span class="nx">state</span> <span class="o">==</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">TransientFailure</span> <span class="p">{</span>
		<span class="nx">lb</span><span class="p">.</span><span class="nx">picker</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">errPicker</span><span class="p">{</span><span class="nx">err</span><span class="p">:</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">ErrTransientFailure</span><span class="p">}</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">// 创建 errpicker
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">lb</span><span class="p">.</span><span class="nx">state</span> <span class="o">==</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">Connecting</span> <span class="p">{</span>
		<span class="nx">lb</span><span class="p">.</span><span class="nx">picker</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">errPicker</span><span class="p">{</span><span class="nx">err</span><span class="p">:</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">ErrNoSubConnAvailable</span><span class="p">}</span>
		<span class="k">return</span>
	<span class="p">}</span>
	
  <span class="c1">// 如果是 pickFirst， 则获取第一个 subConn 就行了
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">readySCs</span> <span class="p">[]</span><span class="nx">balancer</span><span class="p">.</span><span class="nx">SubConn</span>
	<span class="k">if</span> <span class="nx">lb</span><span class="p">.</span><span class="nx">usePickFirst</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">sc</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">lb</span><span class="p">.</span><span class="nx">subConns</span> <span class="p">{</span>
			<span class="nx">readySCs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">readySCs</span><span class="p">,</span> <span class="nx">sc</span><span class="p">)</span>
			<span class="k">break</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">a</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">lb</span><span class="p">.</span><span class="nx">backendAddrsWithoutMetadata</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">sc</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">lb</span><span class="p">.</span><span class="nx">subConns</span><span class="p">[</span><span class="nx">a</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
				<span class="k">if</span> <span class="nx">st</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">lb</span><span class="p">.</span><span class="nx">scStates</span><span class="p">[</span><span class="nx">sc</span><span class="p">];</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">st</span> <span class="o">==</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">Ready</span> <span class="p">{</span>
					<span class="nx">readySCs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">readySCs</span><span class="p">,</span> <span class="nx">sc</span><span class="p">)</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">readySCs</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// If there&#39;s no ready SubConns, always re-pick. This is to avoid drops
</span><span class="c1"></span>		<span class="c1">// unless at least one SubConn is ready. Otherwise we may drop more
</span><span class="c1"></span>		<span class="c1">// often than want because of drops + re-picks(which become re-drops).
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// This doesn&#39;t seem to be necessary after the connecting check above.
</span><span class="c1"></span>		<span class="c1">// Kept for safety.
</span><span class="c1"></span>		<span class="nx">lb</span><span class="p">.</span><span class="nx">picker</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">errPicker</span><span class="p">{</span><span class="nx">err</span><span class="p">:</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">ErrNoSubConnAvailable</span><span class="p">}</span>
		<span class="k">return</span>
	<span class="p">}</span>
  <span class="c1">// 如果是 fallback，则使用 RoundRobin
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">lb</span><span class="p">.</span><span class="nx">inFallback</span> <span class="p">{</span>
		<span class="nx">lb</span><span class="p">.</span><span class="nx">picker</span> <span class="p">=</span> <span class="nf">newRRPicker</span><span class="p">(</span><span class="nx">readySCs</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
  <span class="c1">// 如果是需要重置，创建新的 Picker
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">resetDrop</span> <span class="p">{</span>
		<span class="nx">lb</span><span class="p">.</span><span class="nx">picker</span> <span class="p">=</span> <span class="nf">newLBPicker</span><span class="p">(</span><span class="nx">lb</span><span class="p">.</span><span class="nx">fullServerList</span><span class="p">,</span> <span class="nx">readySCs</span><span class="p">,</span> <span class="nx">lb</span><span class="p">.</span><span class="nx">clientStats</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
  <span class="c1">// 原来的 Picker 不是 lbPicker，创建新 Picker
</span><span class="c1"></span>	<span class="nx">prevLBPicker</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">lb</span><span class="p">.</span><span class="nx">picker</span><span class="p">.(</span><span class="o">*</span><span class="nx">lbPicker</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">lb</span><span class="p">.</span><span class="nx">picker</span> <span class="p">=</span> <span class="nf">newLBPicker</span><span class="p">(</span><span class="nx">lb</span><span class="p">.</span><span class="nx">fullServerList</span><span class="p">,</span> <span class="nx">readySCs</span><span class="p">,</span> <span class="nx">lb</span><span class="p">.</span><span class="nx">clientStats</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
  <span class="c1">// 更新 SubConn
</span><span class="c1"></span>	<span class="nx">prevLBPicker</span><span class="p">.</span><span class="nf">updateReadySCs</span><span class="p">(</span><span class="nx">readySCs</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h2 id="5-后端服务建立连接">5. 后端服务建立连接</h2>
<p>虽然前面剖析了 Balancer 的实现原理，但我们却并不知道与后端服务的连接是在哪里建立的，答案就在 <code>ClientConn.NewSubConn</code>中：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">ccb</span> <span class="o">*</span><span class="nx">ccBalancerWrapper</span><span class="p">)</span> <span class="nf">NewSubConn</span><span class="p">(</span><span class="nx">addrs</span> <span class="p">[]</span><span class="nx">resolver</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">opts</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">NewSubConnOptions</span><span class="p">)</span> <span class="p">(</span><span class="nx">balancer</span><span class="p">.</span><span class="nx">SubConn</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">addrs</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;grpc: cannot create SubConn with empty address list&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">ccb</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">ccb</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">ccb</span><span class="p">.</span><span class="nx">subConns</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;grpc: ClientConn balancer wrapper was closed&#34;</span><span class="p">)</span>
	<span class="p">}</span>
  <span class="c1">// 调用 grpc.ClientConn.newAddrConn 来创建于后端服务的连接
</span><span class="c1"></span>	<span class="nx">ac</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ccb</span><span class="p">.</span><span class="nx">cc</span><span class="p">.</span><span class="nf">newAddrConn</span><span class="p">(</span><span class="nx">addrs</span><span class="p">,</span> <span class="nx">opts</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="nx">acbw</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">acBalancerWrapper</span><span class="p">{</span><span class="nx">ac</span><span class="p">:</span> <span class="nx">ac</span><span class="p">}</span>
	<span class="nx">acbw</span><span class="p">.</span><span class="nx">ac</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="nx">ac</span><span class="p">.</span><span class="nx">acbw</span> <span class="p">=</span> <span class="nx">acbw</span>
	<span class="nx">acbw</span><span class="p">.</span><span class="nx">ac</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
  <span class="c1">// 
</span><span class="c1"></span>	<span class="nx">ccb</span><span class="p">.</span><span class="nx">subConns</span><span class="p">[</span><span class="nx">acbw</span><span class="p">]</span> <span class="p">=</span> <span class="kd">struct</span><span class="p">{}{}</span>
	<span class="k">return</span> <span class="nx">acbw</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>在 NewSubConn 中会调用 <code>cc.newAddrConn</code> 来建立连接对象 <code>acBalancerWrapper</code> 并把它添加到 ClientConn 的 conns 连接池中，但是并没有真正建立连接，而只是初始化了连接状态为 <code>Idle</code>，然后返回了连接的实例：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// newAddrConn creates an addrConn for addrs and adds it to cc.conns.
</span><span class="c1">//
</span><span class="c1">// Caller needs to make sure len(addrs) &gt; 0.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">cc</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">)</span> <span class="nf">newAddrConn</span><span class="p">(</span><span class="nx">addrs</span> <span class="p">[]</span><span class="nx">resolver</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">opts</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">NewSubConnOptions</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">addrConn</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">ac</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">addrConn</span><span class="p">{</span>
		<span class="nx">state</span><span class="p">:</span>        <span class="nx">connectivity</span><span class="p">.</span><span class="nx">Idle</span><span class="p">,</span>	<span class="c1">// 初始化状态为 Idle
</span><span class="c1"></span>		<span class="nx">cc</span><span class="p">:</span>           <span class="nx">cc</span><span class="p">,</span>
		<span class="nx">addrs</span><span class="p">:</span>        <span class="nx">addrs</span><span class="p">,</span>
		<span class="nx">scopts</span><span class="p">:</span>       <span class="nx">opts</span><span class="p">,</span>
		<span class="nx">dopts</span><span class="p">:</span>        <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">,</span>
		<span class="nx">czData</span><span class="p">:</span>       <span class="nb">new</span><span class="p">(</span><span class="nx">channelzData</span><span class="p">),</span>
		<span class="nx">resetBackoff</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}),</span>
	<span class="p">}</span>
	<span class="nx">ac</span><span class="p">.</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">cancel</span> <span class="p">=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithCancel</span><span class="p">(</span><span class="nx">cc</span><span class="p">.</span><span class="nx">ctx</span><span class="p">)</span>
	<span class="c1">// Track ac in cc. This needs to be done before any getTransport(...) is called.
</span><span class="c1"></span>	<span class="nx">cc</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">conns</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">cc</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">ErrClientConnClosing</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">channelz</span><span class="p">.</span><span class="nf">IsOn</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">ac</span><span class="p">.</span><span class="nx">channelzID</span> <span class="p">=</span> <span class="nx">channelz</span><span class="p">.</span><span class="nf">RegisterSubChannel</span><span class="p">(</span><span class="nx">ac</span><span class="p">,</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">channelzID</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">)</span>
		<span class="nx">channelz</span><span class="p">.</span><span class="nf">AddTraceEvent</span><span class="p">(</span><span class="nx">logger</span><span class="p">,</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">channelzID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">channelz</span><span class="p">.</span><span class="nx">TraceEventDesc</span><span class="p">{</span>
			<span class="nx">Desc</span><span class="p">:</span>     <span class="s">&#34;Subchannel Created&#34;</span><span class="p">,</span>
			<span class="nx">Severity</span><span class="p">:</span> <span class="nx">channelz</span><span class="p">.</span><span class="nx">CtInfo</span><span class="p">,</span>
			<span class="nx">Parent</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">channelz</span><span class="p">.</span><span class="nx">TraceEventDesc</span><span class="p">{</span>
				<span class="nx">Desc</span><span class="p">:</span>     <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;Subchannel(id:%d) created&#34;</span><span class="p">,</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">channelzID</span><span class="p">),</span>
				<span class="nx">Severity</span><span class="p">:</span> <span class="nx">channelz</span><span class="p">.</span><span class="nx">CtInfo</span><span class="p">,</span>
			<span class="p">},</span>
		<span class="p">})</span>
	<span class="p">}</span>
	<span class="nx">cc</span><span class="p">.</span><span class="nx">conns</span><span class="p">[</span><span class="nx">ac</span><span class="p">]</span> <span class="p">=</span> <span class="kd">struct</span><span class="p">{}{}</span>
	<span class="nx">cc</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="k">return</span> <span class="nx">ac</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><h3 id="acbalancerwrapper">acBalancerWrapper</h3>
<p>acBalancerWrapper 是 addrConn 的 wrapper，实现了 SubConn 接口：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// acBalancerWrapper is a wrapper on top of ac for balancers.
</span><span class="c1">// It implements balancer.SubConn interface.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">acBalancerWrapper</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">mu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
	<span class="nx">ac</span> <span class="o">*</span><span class="nx">addrConn</span>
<span class="p">}</span>

<span class="c1">// SubConn represents a gRPC sub connection.
</span><span class="c1">// Each sub connection contains a list of addresses. gRPC will
</span><span class="c1">// try to connect to them (in sequence), and stop trying the
</span><span class="c1">// remainder once one connection is successful.
</span><span class="c1">// gRPC 会按顺序尝试连接所有的地址, 在成功连接一个之后停止连接
</span><span class="c1">//
</span><span class="c1">// The reconnect backoff will be applied on the list, not a single address.
</span><span class="c1">// For example, try_on_all_addresses -&gt; backoff -&gt; try_on_all_addresses.
</span><span class="c1">//
</span><span class="c1">// All SubConns start in IDLE, and will not try to connect. To trigger
</span><span class="c1">// the connecting, Balancers must call Connect.
</span><span class="c1">// When the connection encounters an error, it will reconnect immediately.
</span><span class="c1">// When the connection becomes IDLE, it will not reconnect unless Connect is
</span><span class="c1">// called.
</span><span class="c1">//
</span><span class="c1">// This interface is to be implemented by gRPC. Users should not need a
</span><span class="c1">// brand new implementation of this interface. For the situations like
</span><span class="c1">// testing, the new implementation should embed this interface. This allows
</span><span class="c1">// gRPC to add new methods to this interface.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">SubConn</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="c1">// UpdateAddresses updates the addresses used in this SubConn.
</span><span class="c1"></span>	<span class="c1">// gRPC checks if currently-connected address is still in the new list.
</span><span class="c1"></span>	<span class="c1">// If it&#39;s in the list, the connection will be kept.
</span><span class="c1"></span>	<span class="c1">// If it&#39;s not in the list, the connection will gracefully closed, and
</span><span class="c1"></span>	<span class="c1">// a new connection will be created.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// This will trigger a state transition for the SubConn.
</span><span class="c1"></span>	<span class="nf">UpdateAddresses</span><span class="p">([]</span><span class="nx">resolver</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span>
	<span class="c1">// Connect starts the connecting for this SubConn.
</span><span class="c1"></span>	<span class="nf">Connect</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>在完成 NewSubConn 的调用后，还需要手动调用 <code>SubConn.Connect</code> 来完成连接的建立，在 Connect 中又会调用 <code>addrConn.connect</code>：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">acbw</span> <span class="o">*</span><span class="nx">acBalancerWrapper</span><span class="p">)</span> <span class="nf">Connect</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">acbw</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">acbw</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="nx">acbw</span><span class="p">.</span><span class="nx">ac</span><span class="p">.</span><span class="nf">connect</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">ac</span> <span class="o">*</span><span class="nx">addrConn</span><span class="p">)</span> <span class="nf">connect</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">ac</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
  <span class="c1">// 连接已经关闭，返回错误
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">state</span> <span class="o">==</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">Shutdown</span> <span class="p">{</span>
		<span class="nx">ac</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
		<span class="k">return</span> <span class="nx">errConnClosing</span>
	<span class="p">}</span>
  <span class="c1">// 连接状态不是 Idle，说明正在连接中，或者已经创建了连接
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">state</span> <span class="o">!=</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">Idle</span> <span class="p">{</span>
		<span class="nx">ac</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="c1">// Update connectivity state within the lock to prevent subsequent or
</span><span class="c1"></span>	<span class="c1">// concurrent calls from resetting the transport more than once.
</span><span class="c1"></span>  <span class="c1">// 把连接状态更新为连接中
</span><span class="c1"></span>	<span class="nx">ac</span><span class="p">.</span><span class="nf">updateConnectivityState</span><span class="p">(</span><span class="nx">connectivity</span><span class="p">.</span><span class="nx">Connecting</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="nx">ac</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

	<span class="c1">// Start a goroutine connecting to the server asynchronously.
</span><span class="c1"></span>  <span class="c1">// 异步连接服务器
</span><span class="c1"></span>	<span class="k">go</span> <span class="nx">ac</span><span class="p">.</span><span class="nf">resetTransport</span><span class="p">()</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><h3 id="addrconnupdateconnectivitystate">addrConn.updateConnectivityState</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">ac</span> <span class="o">*</span><span class="nx">addrConn</span><span class="p">)</span> <span class="nf">updateConnectivityState</span><span class="p">(</span><span class="nx">s</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">State</span><span class="p">,</span> <span class="nx">lastErr</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">state</span> <span class="o">==</span> <span class="nx">s</span> <span class="p">{</span>
      <span class="k">return</span>
   <span class="p">}</span>
   <span class="nx">ac</span><span class="p">.</span><span class="nx">state</span> <span class="p">=</span> <span class="nx">s</span>
   <span class="nx">channelz</span><span class="p">.</span><span class="nf">Infof</span><span class="p">(</span><span class="nx">logger</span><span class="p">,</span> <span class="nx">ac</span><span class="p">.</span><span class="nx">channelzID</span><span class="p">,</span> <span class="s">&#34;Subchannel Connectivity change to %v&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
   <span class="nx">ac</span><span class="p">.</span><span class="nx">cc</span><span class="p">.</span><span class="nf">handleSubConnStateChange</span><span class="p">(</span><span class="nx">ac</span><span class="p">.</span><span class="nx">acbw</span><span class="p">,</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">lastErr</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>updateConnectivityState 会调用 <code>ClientConn.handleSubConnStateChange</code> 来通知 gRPC 子连接状态发生变化，那 ClientConn 又是如何通知 Balancer 的呢？</p>
<p>调用链如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">addrConn</span><span class="p">.</span><span class="nx">updateConnectivityState</span> <span class="o">-</span><span class="p">&gt;</span> <span class="nx">ClientConn</span><span class="p">.</span><span class="nx">handleSubConnStateChange</span> <span class="o">-</span><span class="p">&gt;</span> <span class="nx">ccBalancerWrapper</span><span class="p">.</span><span class="nx">handleSubConnStateChange</span> <span class="o">-</span><span class="p">&gt;</span> <span class="nx">ccb</span><span class="p">.</span><span class="nx">scBuffer</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">scStateUpdate</span><span class="p">{</span>
		<span class="nx">sc</span><span class="p">:</span>    <span class="nx">sc</span><span class="p">,</span>
		<span class="nx">state</span><span class="p">:</span> <span class="nx">s</span><span class="p">,</span>
		<span class="nx">err</span><span class="p">:</span>   <span class="nx">err</span><span class="p">,</span>
	<span class="p">})</span> <span class="c1">// 发送到 channel
</span></code></pre></div><p>还记得 watcher 函数吗？在 Build 的时候会启动一个协程来执行这个方法：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// watcher balancer functions sequentially, so the balancer can be implemented
</span><span class="c1">// lock-free.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">ccb</span> <span class="o">*</span><span class="nx">ccBalancerWrapper</span><span class="p">)</span> <span class="nf">watcher</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="c1">// handleSubConnStateChange触发
</span><span class="c1"></span>		<span class="k">case</span> <span class="nx">t</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ccb</span><span class="p">.</span><span class="nx">scBuffer</span><span class="p">.</span><span class="nf">Get</span><span class="p">():</span>
			<span class="nx">ccb</span><span class="p">.</span><span class="nx">scBuffer</span><span class="p">.</span><span class="nf">Load</span><span class="p">()</span>
			<span class="k">if</span> <span class="nx">ccb</span><span class="p">.</span><span class="nx">done</span><span class="p">.</span><span class="nf">HasFired</span><span class="p">()</span> <span class="p">{</span>
				<span class="k">break</span>
			<span class="p">}</span>
			<span class="nx">ccb</span><span class="p">.</span><span class="nx">balancerMu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
			<span class="nx">su</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.(</span><span class="o">*</span><span class="nx">scStateUpdate</span><span class="p">)</span>
			<span class="nx">ccb</span><span class="p">.</span><span class="nx">balancer</span><span class="p">.</span><span class="nf">UpdateSubConnState</span><span class="p">(</span><span class="nx">su</span><span class="p">.</span><span class="nx">sc</span><span class="p">,</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">SubConnState</span><span class="p">{</span><span class="nx">ConnectivityState</span><span class="p">:</span> <span class="nx">su</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="nx">ConnectionError</span><span class="p">:</span> <span class="nx">su</span><span class="p">.</span><span class="nx">err</span><span class="p">})</span>
			<span class="nx">ccb</span><span class="p">.</span><span class="nx">balancerMu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">ccb</span><span class="p">.</span><span class="nx">done</span><span class="p">.</span><span class="nf">Done</span><span class="p">():</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="nx">ccb</span><span class="p">.</span><span class="nx">done</span><span class="p">.</span><span class="nf">HasFired</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">ccb</span><span class="p">.</span><span class="nx">balancer</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
			<span class="nx">ccb</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
			<span class="nx">scs</span> <span class="o">:=</span> <span class="nx">ccb</span><span class="p">.</span><span class="nx">subConns</span>
			<span class="nx">ccb</span><span class="p">.</span><span class="nx">subConns</span> <span class="p">=</span> <span class="kc">nil</span>
			<span class="nx">ccb</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
			<span class="k">for</span> <span class="nx">acbw</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">scs</span> <span class="p">{</span>
				<span class="nx">ccb</span><span class="p">.</span><span class="nx">cc</span><span class="p">.</span><span class="nf">removeAddrConn</span><span class="p">(</span><span class="nx">acbw</span><span class="p">.</span><span class="nf">getAddrConn</span><span class="p">(),</span> <span class="nx">errConnDrain</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">ccb</span><span class="p">.</span><span class="nf">UpdateState</span><span class="p">(</span><span class="nx">balancer</span><span class="p">.</span><span class="nx">State</span><span class="p">{</span><span class="nx">ConnectivityState</span><span class="p">:</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">Connecting</span><span class="p">,</span> <span class="nx">Picker</span><span class="p">:</span> <span class="kc">nil</span><span class="p">})</span>
			<span class="k">return</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>哈哈，我们又回到了这里。看来 watcher 方法的工作就是监听子连接的状态变化，并且调用 <code>balancer.UpdateSubConnState</code> 来执行更新操作。</p>
<h3 id="balancerupdatesubconnstate">balancer.UpdateSubConnState</h3>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">lb</span> <span class="o">*</span><span class="nx">lbBalancer</span><span class="p">)</span> <span class="nf">UpdateSubConnState</span><span class="p">(</span><span class="nx">sc</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">SubConn</span><span class="p">,</span> <span class="nx">scs</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">SubConnState</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">s</span> <span class="o">:=</span> <span class="nx">scs</span><span class="p">.</span><span class="nx">ConnectivityState</span>
	<span class="k">if</span> <span class="nx">logger</span><span class="p">.</span><span class="nf">V</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">logger</span><span class="p">.</span><span class="nf">Infof</span><span class="p">(</span><span class="s">&#34;lbBalancer: handle SubConn state change: %p, %v&#34;</span><span class="p">,</span> <span class="nx">sc</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">lb</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">lb</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

	<span class="nx">oldS</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">lb</span><span class="p">.</span><span class="nx">scStates</span><span class="p">[</span><span class="nx">sc</span><span class="p">]</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">logger</span><span class="p">.</span><span class="nf">V</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">logger</span><span class="p">.</span><span class="nf">Infof</span><span class="p">(</span><span class="s">&#34;lbBalancer: got state changes for an unknown SubConn: %p, %v&#34;</span><span class="p">,</span> <span class="nx">sc</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">lb</span><span class="p">.</span><span class="nx">scStates</span><span class="p">[</span><span class="nx">sc</span><span class="p">]</span> <span class="p">=</span> <span class="nx">s</span>
	<span class="k">switch</span> <span class="nx">s</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">Idle</span><span class="p">:</span>	<span class="c1">// Idle，则重新建立连接
</span><span class="c1"></span>		<span class="nx">sc</span><span class="p">.</span><span class="nf">Connect</span><span class="p">()</span>
	<span class="k">case</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">Shutdown</span><span class="p">:</span>	<span class="c1">// Shutdown， 删除当前连接
</span><span class="c1"></span>		<span class="c1">// When an address was removed by resolver, b called RemoveSubConn but
</span><span class="c1"></span>		<span class="c1">// kept the sc&#39;s state in scStates. Remove state for this sc here.
</span><span class="c1"></span>		<span class="nb">delete</span><span class="p">(</span><span class="nx">lb</span><span class="p">.</span><span class="nx">scStates</span><span class="p">,</span> <span class="nx">sc</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// Force regenerate picker if
</span><span class="c1"></span>	<span class="c1">//  - this sc became ready from not-ready
</span><span class="c1"></span>	<span class="c1">//  - this sc became not-ready from ready
</span><span class="c1"></span>  <span class="c1">// 更新状态，已经重新生成 picker
</span><span class="c1"></span>	<span class="nx">lb</span><span class="p">.</span><span class="nf">updateStateAndPicker</span><span class="p">((</span><span class="nx">oldS</span> <span class="o">==</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">Ready</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="nx">s</span> <span class="o">==</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">Ready</span><span class="p">),</span> <span class="kc">false</span><span class="p">)</span>

	<span class="c1">// Enter fallback when the aggregated state is not Ready and the connection
</span><span class="c1"></span>	<span class="c1">// to remote balancer is lost.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">lb</span><span class="p">.</span><span class="nx">state</span> <span class="o">!=</span> <span class="nx">connectivity</span><span class="p">.</span><span class="nx">Ready</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">lb</span><span class="p">.</span><span class="nx">inFallback</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">lb</span><span class="p">.</span><span class="nx">remoteBalancerConnected</span> <span class="p">{</span>
			<span class="c1">// Enter fallback.
</span><span class="c1"></span>			<span class="nx">lb</span><span class="p">.</span><span class="nf">refreshSubConns</span><span class="p">(</span><span class="nx">lb</span><span class="p">.</span><span class="nx">resolvedBackendAddrs</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">lb</span><span class="p">.</span><span class="nx">usePickFirst</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h2 id="6-总结">6. 总结</h2>
<p>设计者为了让 Resolver ，Balancer 实现解耦，可谓是煞费苦心，而且也实现的十分优秀。当然 dnsBalancer 的实现相对来说有点复杂，如果没有使用过 grpclb 的话，理解起来会有点困难，不过这并不影响我们学习 Balancer 的设计思想，下面是调用关系总结：</p>
<p><img src="https://blog-wero.oss-cn-shanghai.aliyuncs.com/img/resolver-balancer-clientconn%E4%BA%A4%E4%BA%92%E6%B5%81%E7%A8%8B.png" alt=""></p>
<p>咱们下篇文章见！</p>
]]></content>
		</item>
		
		<item>
			<title>gRPC Resolver 分析</title>
			<link>https://wangzeping722.github.io/posts/grpc-resolver/</link>
			<pubDate>Thu, 29 Oct 2020 09:56:05 +0800</pubDate>
			
			<guid>https://wangzeping722.github.io/posts/grpc-resolver/</guid>
			<description>1. 前言 gRPC Resolver 是 gRPC 的核心功能之一，与 gRPC Balancer 一起负责 gRPC 调用其它服务时的负载均衡。gRPC 负载均衡是针对每次请求，而不是连接，这样可以保证服务端负载的</description>
			<content type="html"><![CDATA[<h2 id="1-前言">1. 前言</h2>
<p>gRPC Resolver 是 gRPC 的核心功能之一，与 gRPC Balancer 一起负责 gRPC 调用其它服务时的负载均衡。gRPC 负载均衡是针对每次请求，而不是连接，这样可以保证服务端负载的均衡性，所有 gRPC 负载均衡算法实现都在客户端。</p>
<h2 id="2-resolver">2. Resolver</h2>
<p>下图是 gRPC 客户端负载均衡的架构图：</p>
<p><!-- raw HTML omitted --></p>
<p>从图中可以看出，Resolver 位于图片的左方，gRPC 负载与 Resolver 交互：</p>
<ol>
<li>首先会 Build 一个 Resolver 实例，并且 watch 后端服务列表的变化</li>
<li>当服务列表发生变化后，Resolver 通过 gRPC 通知 Balancer</li>
</ol>
<h2 id="3-基本概念">3. 基本概念</h2>
<p><code>ClientConn</code> 对象是连接管理的入口，表示到服务端的一个逻辑的连接，会做名字解析、负载均衡、KeepAlive 等连接管理方面的操作，是个线程安全的对象。</p>
<p>每个 <code>ClientConn</code> 对应有多个 <code>SubConn</code>，<code>ClientConn</code> 会基于服务发现（resolver）得到多个 SubConn，并在多个 <code>SubConn</code> 之间实现负载均衡（balancer）。</p>
<h2 id="4-源码分析">4. 源码分析</h2>
<p>Resolver 的代码主要集中在 resolver 包中，里面主要包含了服务解析的接口定义，我们既可以自己通过实现 resolver 中的接口来自定义自己的 Resolver，也可以使用 gRPC 实现的 <a href="https://github.com/grpc/grpc-go/blob/master/internal/resolver/dns/dns_resolver.go">DNSResolver</a>。</p>
<h3 id="address">Address</h3>
<p>Address 用来代表一个当前客户端即将连接到的服务端的地址，一个服务一般会有多个地址，所有我们在监听的时候一般会获取到 Address 的切片。其中的 <code>Addr</code> 字段是服务器的地址, <code>Attributes</code>  和 <code>Metadata</code> 用来存储服务端的额外的信息，一般被负载均衡器用来决定 pick 哪一条连接：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Address represents a server the client connects to.
</span><span class="c1">//
</span><span class="c1">// Experimental
</span><span class="c1">//
</span><span class="c1">// Notice: This type is EXPERIMENTAL and may be changed or removed in a
</span><span class="c1">// later release.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Address</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// Addr is the server address on which a connection will be established.
</span><span class="c1"></span>	<span class="nx">Addr</span> <span class="kt">string</span>

	<span class="c1">// ServerName is the name of this address.
</span><span class="c1"></span>	<span class="c1">// If non-empty, the ServerName is used as the transport certification authority for
</span><span class="c1"></span>	<span class="c1">// the address, instead of the hostname from the Dial target string. In most cases,
</span><span class="c1"></span>	<span class="c1">// this should not be set.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// If Type is GRPCLB, ServerName should be the name of the remote load
</span><span class="c1"></span>	<span class="c1">// balancer, not the name of the backend.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// WARNING: ServerName must only be populated with trusted values. It
</span><span class="c1"></span>	<span class="c1">// is insecure to populate it with data from untrusted inputs since untrusted
</span><span class="c1"></span>	<span class="c1">// values could be used to bypass the authority checks performed by TLS.
</span><span class="c1"></span>	<span class="nx">ServerName</span> <span class="kt">string</span>

	<span class="c1">// Attributes contains arbitrary data about this address intended for
</span><span class="c1"></span>	<span class="c1">// consumption by the load balancing policy.
</span><span class="c1"></span>	<span class="nx">Attributes</span> <span class="o">*</span><span class="nx">attributes</span><span class="p">.</span><span class="nx">Attributes</span>

	<span class="c1">// Type is the type of this address.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Deprecated: use Attributes instead.
</span><span class="c1"></span>	<span class="nx">Type</span> <span class="nx">AddressType</span>

	<span class="c1">// Metadata is the information associated with Addr, which may be used
</span><span class="c1"></span>	<span class="c1">// to make load balancing decision.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Deprecated: use Attributes instead.
</span><span class="c1"></span>	<span class="nx">Metadata</span> <span class="kd">interface</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre></div><h3 id="clientconn">ClientConn</h3>
<p>ClientConn 为 resolver 提供了通知 ClientConn 更新服务端列表的回调方法。这个接口不推荐用户自己实现：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// ClientConn contains the callbacks for resolver to notify any updates
</span><span class="c1">// to the gRPC ClientConn.
</span><span class="c1">//
</span><span class="c1">// This interface is to be implemented by gRPC. Users should not need a
</span><span class="c1">// brand new implementation of this interface. For the situations like
</span><span class="c1">// testing, the new implementation should embed this interface. This allows
</span><span class="c1">// gRPC to add new methods to this interface.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ClientConn</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="c1">// UpdateState updates the state of the ClientConn appropriately.
</span><span class="c1"></span>	<span class="nf">UpdateState</span><span class="p">(</span><span class="nx">State</span><span class="p">)</span>
	<span class="c1">// ReportError notifies the ClientConn that the Resolver encountered an
</span><span class="c1"></span>	<span class="c1">// error.  The ClientConn will notify the load balancer and begin calling
</span><span class="c1"></span>	<span class="c1">// ResolveNow on the Resolver with exponential backoff.
</span><span class="c1"></span>	<span class="nf">ReportError</span><span class="p">(</span><span class="kt">error</span><span class="p">)</span>
	<span class="c1">// NewAddress is called by resolver to notify ClientConn a new list
</span><span class="c1"></span>	<span class="c1">// of resolved addresses.
</span><span class="c1"></span>	<span class="c1">// The address list should be the complete list of resolved addresses.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Deprecated: Use UpdateState instead.
</span><span class="c1"></span>	<span class="nf">NewAddress</span><span class="p">(</span><span class="nx">addresses</span> <span class="p">[]</span><span class="nx">Address</span><span class="p">)</span>
	<span class="c1">// NewServiceConfig is called by resolver to notify ClientConn a new
</span><span class="c1"></span>	<span class="c1">// service config. The service config should be provided as a json string.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Deprecated: Use UpdateState instead.
</span><span class="c1"></span>	<span class="nf">NewServiceConfig</span><span class="p">(</span><span class="nx">serviceConfig</span> <span class="kt">string</span><span class="p">)</span>
	<span class="c1">// ParseServiceConfig parses the provided service config and returns an
</span><span class="c1"></span>	<span class="c1">// object that provides the parsed config.
</span><span class="c1"></span>	<span class="nf">ParseServiceConfig</span><span class="p">(</span><span class="nx">serviceConfigJSON</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">serviceconfig</span><span class="p">.</span><span class="nx">ParseResult</span>
<span class="p">}</span>
</code></pre></div><p>一般我们的 Resolver 中都会用一个成员变量来存储 ClientConn，然后再需要更新服务端地址的时候调用 <code>UpdateState</code>。例如 dnsResolver 中存储了 <code>cc</code>：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">dnsResolver</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="o">...</span>
	<span class="nx">cc</span>       <span class="nx">resolver</span><span class="p">.</span><span class="nx">ClientConn</span>
	<span class="o">...</span>
<span class="p">}</span>
</code></pre></div><h3 id="target">Target</h3>
<p>Target 是一个存储注册中心信息和后端服务信息的结构体, 并且通过 Scheme 指定了 gRPC 使用的解析器的名称：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Target represents a target for gRPC, as specified in:
</span><span class="c1">// https://github.com/grpc/grpc/blob/master/doc/naming.md.
</span><span class="c1">// It is parsed from the target string that gets passed into Dial or DialContext by the user. And
</span><span class="c1">// grpc passes it to the resolver and the balancer.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Target</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Scheme</span>    <span class="kt">string</span>	<span class="c1">// 注册在 gRPC 中的名称
</span><span class="c1"></span>	<span class="nx">Authority</span> <span class="kt">string</span>	<span class="c1">// 服务发现的权威服务器
</span><span class="c1"></span>	<span class="nx">Endpoint</span>  <span class="kt">string</span>	<span class="c1">// 一般是服务名或者HOST
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>例如我们有一个 Target 是 <code>dns://some_authority/foo.bar</code>， 那么对应的被解析出来就应该是</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">Scheme</span> <span class="p">=</span> <span class="nx">dns</span>
<span class="nx">Authority</span> <span class="p">=</span> <span class="nx">some_authority</span>
<span class="nx">Endpoint</span> <span class="p">=</span> <span class="nx">foo</span><span class="p">.</span><span class="nx">bar</span>
</code></pre></div><h3 id="builder">Builder</h3>
<p>Builder 接口为我们提供了创建 Resolver 的 Build 方法，并且持续监听服务端地址的变化：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Builder creates a resolver that will be used to watch name resolution updates.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Builder</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="c1">// Build creates a new resolver for the given target.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// gRPC dial calls Build synchronously, and fails if the returned error is
</span><span class="c1"></span>	<span class="c1">// not nil.
</span><span class="c1"></span>	<span class="nf">Build</span><span class="p">(</span><span class="nx">target</span> <span class="nx">Target</span><span class="p">,</span> <span class="nx">cc</span> <span class="nx">ClientConn</span><span class="p">,</span> <span class="nx">opts</span> <span class="nx">BuildOptions</span><span class="p">)</span> <span class="p">(</span><span class="nx">Resolver</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
	<span class="c1">// Scheme returns the scheme supported by this resolver.
</span><span class="c1"></span>	<span class="c1">// Scheme is defined at https://github.com/grpc/grpc/blob/master/doc/naming.md.
</span><span class="c1"></span>	<span class="nf">Scheme</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>
</code></pre></div><p>从注释中，我们可以理解到：当向 gRPC 注册解析器的时候，实际上注册的是 Builder，通过 Build 方法来创建 Resolver，并且一般会在 Build 方法中开启 goroutine 来 watch 服务端的变化。</p>
<p>Build 方法的参数就包含了上节提到的 <code>cc ClientConn</code>，然后如上文说的，把 cc 存储到 Resolver 中，在观察到服务地址发生变化的时候</p>
<p>通过 <code>cc.UpdateState(resolver.State{Addresses: addr})</code> 来通知 ClientConn 服务器列表发生变化。</p>
<h3 id="resolver">Resolver</h3>
<p>Resolver 被 Builder 创建出来，实现了监听服务名映射到的地址变化的逻辑：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Resolver watches for the updates on the specified target.
</span><span class="c1">// Updates include address updates and service config updates.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Resolver</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="c1">// ResolveNow will be called by gRPC to try to resolve the target name
</span><span class="c1"></span>	<span class="c1">// again. It&#39;s just a hint, resolver can ignore this if it&#39;s not necessary.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// It could be called multiple times concurrently.
</span><span class="c1"></span>	<span class="nf">ResolveNow</span><span class="p">(</span><span class="nx">ResolveNowOptions</span><span class="p">)</span>
	<span class="c1">// Close closes the resolver.
</span><span class="c1"></span>	<span class="nf">Close</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><h3 id="小结">小结</h3>
<p>resolver 包的使用流程是，通过 Builder 接口来创建 Resolver，我们可以再 Resolver 中实现自己服务发现的逻辑，并且更新到 ClientConn 中。</p>
<h2 id="5-resolver-应用">5. Resolver 应用</h2>
<p>下面我们写一个完整的例子，用来分析 Resolver 的工作流程，我们程序的目的就是客户端通过 rpc 调用服务器的接口并打印出结果。为了减少篇幅，我就不贴出所有的代码，完整的代码可以在我的 <a href="https://github.com/wangzeping722/gRPC-resolver-demo">github</a> 获取。</p>
<h3 id="servermaingo">server/main.go</h3>
<p>通过 NewGreeterService 向 etcd 注册了服务的地址：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">g</span> <span class="o">*</span><span class="nx">greeterService</span><span class="p">)</span> <span class="nf">Register</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">target</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%s&#34;</span><span class="p">,</span> <span class="nx">serviceName</span><span class="p">)</span>
	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="mi">5</span><span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>

	<span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">g</span><span class="p">.</span><span class="nx">cli</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">target</span><span class="p">,</span> <span class="s">&#34;127.0.0.1:8000&#34;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>然后，监听在 8000 这个端口上，等待提供服务。</p>
<h3 id="clientmaingo">client/main.go</h3>
<p>由于本文的重心在于分析 Resolver，那么 client 的代码实现才是我们需要详细解析的。为了能够从 etcd 获取我们后端服务的地址，并且 gRPC 只提供了 dnsResolver，那么我们就要实现自己自定义的 Resolver，这里我们只实现了一个功能非常简单，并且没有 watch（即持续的服务发现）的 Resolver：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">exampleResolver</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">target</span> <span class="nx">resolver</span><span class="p">.</span><span class="nx">Target</span>
	<span class="nx">cc</span>     <span class="nx">resolver</span><span class="p">.</span><span class="nx">ClientConn</span>
	<span class="nx">cli</span>    <span class="o">*</span><span class="nx">clientv3</span><span class="p">.</span><span class="nx">Client</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">exampleResolver</span><span class="p">)</span> <span class="nf">ResolveNow</span><span class="p">(</span><span class="nx">_</span> <span class="nx">resolver</span><span class="p">.</span><span class="nx">ResolveNowOptions</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;ResolverNow&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">exampleResolver</span><span class="p">)</span> <span class="nf">Close</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Close&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">exampleResolver</span><span class="p">)</span> <span class="nf">resolve</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">once</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">clientConfig</span> <span class="o">:=</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nx">Config</span><span class="p">{</span>
			<span class="nx">Endpoints</span><span class="p">:</span>   <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="nx">e</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">Authority</span><span class="p">},</span>
			<span class="nx">DialTimeout</span><span class="p">:</span> <span class="mi">120</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span>
		<span class="p">}</span>
		<span class="nx">cli</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="nx">clientConfig</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">e</span><span class="p">.</span><span class="nx">cli</span> <span class="p">=</span> <span class="nx">cli</span>
	<span class="p">})</span>
	<span class="nx">addList</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">resolver</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="c1">// 获取服务对应的所有的后端地址，并且添加到 addList
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">result</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">cli</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">e</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">Endpoint</span><span class="p">,</span> <span class="nx">clientv3</span><span class="p">.</span><span class="nf">WithPrefix</span><span class="p">());</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">kvs</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">result</span><span class="p">.</span><span class="nx">Kvs</span> <span class="p">{</span>
			<span class="nx">addList</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">addList</span><span class="p">,</span> <span class="nx">resolver</span><span class="p">.</span><span class="nx">Address</span><span class="p">{</span>
				<span class="nx">Addr</span><span class="p">:</span> <span class="nb">string</span><span class="p">(</span><span class="nx">kvs</span><span class="p">.</span><span class="nx">Value</span><span class="p">),</span>
			<span class="p">})</span>
			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;resolved addr: %s\n&#34;</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">kvs</span><span class="p">.</span><span class="nx">Value</span><span class="p">))</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">e</span><span class="p">.</span><span class="nx">cc</span><span class="p">.</span><span class="nf">UpdateState</span><span class="p">(</span><span class="nx">resolver</span><span class="p">.</span><span class="nx">State</span><span class="p">{</span><span class="nx">Addresses</span><span class="p">:</span> <span class="nx">addList</span><span class="p">})</span>
<span class="p">}</span>

</code></pre></div><p>实现 exampleResolver， 可以看到，我们在 resolver 方法中实现了服务发现的代码，获得了服务对应的后端地址，然后通过 <code>cc.UpdateState(resolver.State{Addresses: addList})</code> 更新（添加、删除）本地的后端服务器列表。</p>
<p>同时，我们还需要实现一个 Builder，用来创建 Resolver 实例，同时我们还需要把 Builder 注册到 gRPC 中，通过 <code>Scheme</code> 来标识我们自定义的 Resolver：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">resolver</span><span class="p">.</span><span class="nf">Register</span><span class="p">(</span><span class="nf">newBuilder</span><span class="p">())</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">exampleBuilder</span> <span class="kd">struct</span> <span class="p">{</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">newBuilder</span><span class="p">()</span> <span class="o">*</span><span class="nx">exampleBuilder</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">exampleBuilder</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">exampleBuilder</span><span class="p">)</span> <span class="nf">Build</span><span class="p">(</span><span class="nx">target</span> <span class="nx">resolver</span><span class="p">.</span><span class="nx">Target</span><span class="p">,</span> <span class="nx">cc</span> <span class="nx">resolver</span><span class="p">.</span><span class="nx">ClientConn</span><span class="p">,</span> <span class="nx">opts</span> <span class="nx">resolver</span><span class="p">.</span><span class="nx">BuildOptions</span><span class="p">)</span> <span class="p">(</span><span class="nx">resolver</span><span class="p">.</span><span class="nx">Resolver</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">r</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">exampleResolver</span><span class="p">{</span><span class="nx">cc</span><span class="p">:</span> <span class="nx">cc</span><span class="p">,</span> <span class="nx">target</span><span class="p">:</span> <span class="nx">target</span><span class="p">}</span>
	<span class="nx">r</span><span class="p">.</span><span class="nf">resolve</span><span class="p">()</span>
	<span class="k">return</span> <span class="nx">r</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">b</span> <span class="o">*</span><span class="nx">exampleBuilder</span><span class="p">)</span> <span class="nf">Scheme</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">scheme</span>
<span class="p">}</span>
</code></pre></div><p>再来看看 main 函数做了什么工作：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">target</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%s://%s/%s&#34;</span><span class="p">,</span> <span class="nx">scheme</span><span class="p">,</span> <span class="s">&#34;127.0.0.1:2379&#34;</span><span class="p">,</span> <span class="nx">serviceName</span><span class="p">)</span>
	<span class="nx">ctx</span><span class="p">,</span> <span class="nx">cancel</span> <span class="o">:=</span> <span class="nx">context</span><span class="p">.</span><span class="nf">WithTimeout</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="o">*</span><span class="mi">5</span><span class="p">)</span>
	<span class="k">defer</span> <span class="nf">cancel</span><span class="p">()</span>
	<span class="nx">clientConn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">DialContext</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">target</span><span class="p">,</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">WithInsecure</span><span class="p">())</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

  <span class="c1">// 调用远程服务
</span><span class="c1"></span>	<span class="nx">reply</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">hello</span><span class="p">.</span><span class="nf">NewGreeterClient</span><span class="p">(</span><span class="nx">clientConn</span><span class="p">).</span><span class="nf">SayHello</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="o">&amp;</span><span class="nx">hello</span><span class="p">.</span><span class="nx">HelloRequest</span><span class="p">{</span>
		<span class="nx">Name</span><span class="p">:</span> <span class="s">&#34;wero&#34;</span><span class="p">,</span>
	<span class="p">})</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;get reply:&#34;</span><span class="p">,</span> <span class="nx">reply</span><span class="p">.</span><span class="nx">Message</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>首先，我们通过 <code>target</code> 指出需要调用的远程服务，然后调用  <code>grpc.DialContext</code>，gRPC 便可以自动发现服务的地址了，并在我们调用远程服务的时候实现了负载均衡。不过我们不仅要知其然，更要知其所以然。</p>
<h3 id="dialcontext-流程分析">DialContext 流程分析</h3>
<p>最重要的便是 DialContext 这个函数了，那我们便从这个函数入手：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">DialContext</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">target</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">opts</span> <span class="o">...</span><span class="nx">DialOption</span><span class="p">)</span> <span class="p">(</span><span class="nx">conn</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">cc</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">ClientConn</span><span class="p">{</span>
		<span class="nx">target</span><span class="p">:</span>            <span class="nx">target</span><span class="p">,</span>
		<span class="nx">csMgr</span><span class="p">:</span>             <span class="o">&amp;</span><span class="nx">connectivityStateManager</span><span class="p">{},</span>
		<span class="nx">conns</span><span class="p">:</span>             <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="o">*</span><span class="nx">addrConn</span><span class="p">]</span><span class="kd">struct</span><span class="p">{}),</span>	<span class="c1">// 存储连接的 map
</span><span class="c1"></span>		<span class="nx">dopts</span><span class="p">:</span>             <span class="nf">defaultDialOptions</span><span class="p">(),</span>
		<span class="nx">blockingpicker</span><span class="p">:</span>    <span class="nf">newPickerWrapper</span><span class="p">(),</span>				<span class="c1">// 负载均衡的选择器
</span><span class="c1"></span>		<span class="nx">czData</span><span class="p">:</span>            <span class="nb">new</span><span class="p">(</span><span class="nx">channelzData</span><span class="p">),</span>
		<span class="nx">firstResolveEvent</span><span class="p">:</span> <span class="nx">grpcsync</span><span class="p">.</span><span class="nf">NewEvent</span><span class="p">(),</span>
	<span class="p">}</span>
  
	<span class="o">...</span>
	<span class="c1">// 初始化拦截器
</span><span class="c1"></span>	<span class="nf">chainUnaryClientInterceptors</span><span class="p">(</span><span class="nx">cc</span><span class="p">)</span>
	<span class="nf">chainStreamClientInterceptors</span><span class="p">(</span><span class="nx">cc</span><span class="p">)</span>
	
  <span class="o">...</span>
  
	<span class="c1">// Determine the resolver to use.
</span><span class="c1"></span>	<span class="c1">// 根据 target 上面置顶的 scheme 指定需要使用的 resolver
</span><span class="c1"></span>	<span class="nx">cc</span><span class="p">.</span><span class="nx">parsedTarget</span> <span class="p">=</span> <span class="nx">grpcutil</span><span class="p">.</span><span class="nf">ParseTarget</span><span class="p">(</span><span class="nx">cc</span><span class="p">.</span><span class="nx">target</span><span class="p">)</span>
	<span class="nx">unixScheme</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">HasPrefix</span><span class="p">(</span><span class="nx">cc</span><span class="p">.</span><span class="nx">target</span><span class="p">,</span> <span class="s">&#34;unix:&#34;</span><span class="p">)</span>
	<span class="nx">channelz</span><span class="p">.</span><span class="nf">Infof</span><span class="p">(</span><span class="nx">logger</span><span class="p">,</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">channelzID</span><span class="p">,</span> <span class="s">&#34;parsed scheme: %q&#34;</span><span class="p">,</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">parsedTarget</span><span class="p">.</span><span class="nx">Scheme</span><span class="p">)</span>
	<span class="c1">// NameResolver 核心逻辑, 初始化 resolverBuilder, 如果传入的 scheme 找不到对应的 resolverBuilder, 就使用默认的
</span><span class="c1"></span>	<span class="nx">resolverBuilder</span> <span class="o">:=</span> <span class="nx">cc</span><span class="p">.</span><span class="nf">getResolver</span><span class="p">(</span><span class="nx">cc</span><span class="p">.</span><span class="nx">parsedTarget</span><span class="p">.</span><span class="nx">Scheme</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">resolverBuilder</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// If resolver builder is still nil, the parsed target&#39;s scheme is
</span><span class="c1"></span>		<span class="c1">// not registered. Fallback to default resolver and set Endpoint to
</span><span class="c1"></span>		<span class="c1">// the original target.
</span><span class="c1"></span>		<span class="nx">channelz</span><span class="p">.</span><span class="nf">Infof</span><span class="p">(</span><span class="nx">logger</span><span class="p">,</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">channelzID</span><span class="p">,</span> <span class="s">&#34;scheme %q not registered, fallback to default scheme&#34;</span><span class="p">,</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">parsedTarget</span><span class="p">.</span><span class="nx">Scheme</span><span class="p">)</span>
		<span class="nx">cc</span><span class="p">.</span><span class="nx">parsedTarget</span> <span class="p">=</span> <span class="nx">resolver</span><span class="p">.</span><span class="nx">Target</span><span class="p">{</span>
			<span class="nx">Scheme</span><span class="p">:</span>   <span class="nx">resolver</span><span class="p">.</span><span class="nf">GetDefaultScheme</span><span class="p">(),</span>
			<span class="nx">Endpoint</span><span class="p">:</span> <span class="nx">target</span><span class="p">,</span>
		<span class="p">}</span>
		<span class="nx">resolverBuilder</span> <span class="p">=</span> <span class="nx">cc</span><span class="p">.</span><span class="nf">getResolver</span><span class="p">(</span><span class="nx">cc</span><span class="p">.</span><span class="nx">parsedTarget</span><span class="p">.</span><span class="nx">Scheme</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">resolverBuilder</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;could not get resolver for default scheme: %q&#34;</span><span class="p">,</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">parsedTarget</span><span class="p">.</span><span class="nx">Scheme</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
  
	<span class="o">...</span>
  
	<span class="nx">cc</span><span class="p">.</span><span class="nx">balancerBuildOpts</span> <span class="p">=</span> <span class="nx">balancer</span><span class="p">.</span><span class="nx">BuildOptions</span><span class="p">{</span>
		<span class="nx">DialCreds</span><span class="p">:</span>        <span class="nx">credsClone</span><span class="p">,</span>
		<span class="nx">CredsBundle</span><span class="p">:</span>      <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">copts</span><span class="p">.</span><span class="nx">CredsBundle</span><span class="p">,</span>
		<span class="nx">Dialer</span><span class="p">:</span>           <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">copts</span><span class="p">.</span><span class="nx">Dialer</span><span class="p">,</span>
		<span class="nx">ChannelzParentID</span><span class="p">:</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">channelzID</span><span class="p">,</span>
		<span class="nx">Target</span><span class="p">:</span>           <span class="nx">cc</span><span class="p">.</span><span class="nx">parsedTarget</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="c1">// Build the resolver.
</span><span class="c1"></span>	<span class="c1">// 使用上面初始化的 resolverBuilder 构建 resolver
</span><span class="c1"></span>	<span class="nx">rWrapper</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">newCCResolverWrapper</span><span class="p">(</span><span class="nx">cc</span><span class="p">,</span> <span class="nx">resolverBuilder</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;failed to build resolver: %v&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">cc</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="nx">cc</span><span class="p">.</span><span class="nx">resolverWrapper</span> <span class="p">=</span> <span class="nx">rWrapper</span>
	<span class="nx">cc</span><span class="p">.</span><span class="nx">mu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
  
	<span class="o">...</span>
  
	<span class="k">return</span> <span class="nx">cc</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>代码中省略了一部分目前不关注的内容，可以看见的是，我们需要先通过 <code>target</code> 指定的 <code>scheme</code> 来获取 resolverBuilder， 然后再通过 builder 来构建出 resolver 实例。在我们的例子中 <code>scheme = test</code> ，其对应的 builder 就是上面的 <code>exampleBuilder</code>，代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">cc</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">)</span> <span class="nf">getResolver</span><span class="p">(</span><span class="nx">scheme</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">resolver</span><span class="p">.</span><span class="nx">Builder</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">rb</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">resolvers</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">scheme</span> <span class="o">==</span> <span class="nx">rb</span><span class="p">.</span><span class="nf">Scheme</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">rb</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">resolver</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">scheme</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>在获取到 builder 之后，紧接着就需要构建出用于服务发现的 <code>Resolver</code>，我们接往下看，发现 <code>newCCResolverWrapper(cc, resolverBuilder)</code> 会把获取到的 builder 传入函数中：</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">newCCResolverWrapper</span><span class="p">(</span><span class="nx">cc</span> <span class="o">*</span><span class="nx">ClientConn</span><span class="p">,</span> <span class="nx">rb</span> <span class="nx">resolver</span><span class="p">.</span><span class="nx">Builder</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">ccResolverWrapper</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">ccr</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">ccResolverWrapper</span><span class="p">{</span>
		<span class="nx">cc</span><span class="p">:</span>   <span class="nx">cc</span><span class="p">,</span>
		<span class="nx">done</span><span class="p">:</span> <span class="nx">grpcsync</span><span class="p">.</span><span class="nf">NewEvent</span><span class="p">(),</span>
	<span class="p">}</span>
	<span class="o">...</span>
	<span class="nx">rbo</span> <span class="o">:=</span> <span class="nx">resolve</span> <span class="nx">r</span><span class="p">.</span><span class="nx">BuildOptions</span><span class="p">{</span>
		<span class="nx">DisableServiceConfig</span><span class="p">:</span> <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">disableServiceConfig</span><span class="p">,</span>
		<span class="nx">DialCreds</span><span class="p">:</span>            <span class="nx">credsClone</span><span class="p">,</span>
		<span class="nx">CredsBundle</span><span class="p">:</span>          <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">copts</span><span class="p">.</span><span class="nx">CredsBundle</span><span class="p">,</span>
		<span class="nx">Dialer</span><span class="p">:</span>               <span class="nx">cc</span><span class="p">.</span><span class="nx">dopts</span><span class="p">.</span><span class="nx">copts</span><span class="p">.</span><span class="nx">Dialer</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
	<span class="c1">// We need to hold the lock here while we assign to the ccr.resolver field
</span><span class="c1"></span>	<span class="c1">// to guard against a data race caused by the following code path,
</span><span class="c1"></span>	<span class="c1">// rb.Build--&gt;ccr.ReportError--&gt;ccr.poll--&gt;ccr.resolveNow, would end up
</span><span class="c1"></span>	<span class="c1">// accessing ccr.resolver which is being assigned here.
</span><span class="c1"></span>	<span class="nx">ccr</span><span class="p">.</span><span class="nx">resolverMu</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">ccr</span><span class="p">.</span><span class="nx">resolverMu</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="nx">ccr</span><span class="p">.</span><span class="nx">resolver</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">rb</span><span class="p">.</span><span class="nf">Build</span><span class="p">(</span><span class="nx">cc</span><span class="p">.</span><span class="nx">parsedTarget</span><span class="p">,</span> <span class="nx">ccr</span><span class="p">,</span> <span class="nx">rbo</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">ccr</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>果然，这个函数会调用传入的 Builder，而这个 Builder 是一个接口，具体的实现是我们自定义的 <code>exampleBuilder</code>，在 Build 方法里面，我们一般会开启一个协程持续的获取后端服务器列表的状态，并通过 <code>	UpdateState(State)</code> ，来更新到 ClientConn 中（不过，在我这个建议的实现中，并没有开启协程来处理服务发现，而是一次性的获取，假设后端服务永远不出故障）。</p>
<h3 id="总结">总结</h3>
<p>到这里，对 Resolver 的分析基本完成，下一篇文章会分析 gRPC Balancer。</p>
]]></content>
		</item>
		
		<item>
			<title>DNS学习总结</title>
			<link>https://wangzeping722.github.io/posts/dns-recording/</link>
			<pubDate>Mon, 23 Dec 2019 10:36:05 +0800</pubDate>
			
			<guid>https://wangzeping722.github.io/posts/dns-recording/</guid>
			<description>DNS 有多种记录类型，每种记录都有不同的作用，这篇文章主要总结了常用的记录。 A A（Address）记录用来指定主机名（域名）对应的 IPv4 地址记录。比</description>
			<content type="html"><![CDATA[<p>DNS 有多种记录类型，每种记录都有不同的作用，这篇文章主要总结了常用的记录。</p>
<h4 id="a">A</h4>
<p>A（Address）记录用来指定主机名（域名）对应的 IPv4 地址记录。比如，当你浏览一个网页时候会，浏览器就会先去查找对应域名的 A 记录，来获取 IP 地址，获得了 IP 地址，才能与服务器建立连接。</p>
<blockquote>
<p>我们可以为同一个域名添加多个 A 记录，解析的时候，会得到多个 IP，会随机选择一个使用。</p>
</blockquote>
<p><em>域名不区分大小写。记录的名称应该是由 ASCII 码字母、数字和 - 组成。</em></p>
<h4 id="aaaa">AAAA</h4>
<p>AAAA 记录用来指定主机名（域名）对应的 IPv6 地址记录，其他与 A 相同。</p>
<h4 id="cname-canonical-names">CNAME （canonical names）</h4>
<p>CNAME（规范名称），也就是别名记录，它能够让我们把多个名字映射到同一个主机。</p>
<p>应用场景：</p>
<ul>
<li>使用 CDN 服务时。</li>
<li>假如一个服务器运行着 100 个网站，这 100 个网站 CNAME 到 <code>a.example.com</code>。当该服务器 IP 改变时，你只需改变 <code>a.example.com</code>的 IP 就可以了。</li>
</ul>
<p>注意：由于<code>CNAME</code>记录就是一个替换，所以域名一旦设置<code>CNAME</code>记录以后，就不能再设置其他记录了（比如<code>A</code>记录和<code>MX</code>记录），这是为了防止产生冲突。举例来说，<code>foo.com</code>指向<code>bar.com</code>，而两个域名各有自己的<code>MX</code>记录，如果两者不一致，就会产生问题。由于顶级域名通常要设置<code>MX</code>记录，所以一般不允许用户对顶级域名设置<code>CNAME</code>记录。</p>
<p>A记录是把域名解析到IP地址，而CNAME记录是把域名解析到另外一个域名，而这个域名最终会指向A记录，在功能实现在上A记录与CNAME记录没有区别。</p>
<p>例如：</p>
<pre><code class="language-dns" data-lang="dns">a.example.com       IN      A       192.168.1.101
b.example.com       IN      CNAME   a.example.com（规范名称）
</code></pre><p>你在请求 b.example.com 的时候，他会先返回给你一个 CNAME ，然后你在用 CNAME 去查询。</p>
<h4 id="ns">NS</h4>
<p>NS（Name Server），域名服务器记录，返回保存下一级域名信息的服务器地址。该记录只能设置为域名，不能设置为IP地址。</p>
<p>一般来说，为了服务的安全可靠，至少应该有两条<code>NS</code>记录，而<code>A</code>记录和<code>MX</code>记录也可以有多条，这样就提供了服务的冗余性，防止出现单点失败。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ dig NS google.com
google.com.		777	IN	NS	ns4.google.com.
google.com.		777	IN	NS	ns3.google.com.
google.com.		777	IN	NS	ns2.google.com.
google.com.		777	IN	NS	ns1.google.com.
</code></pre></div><p>我们可以看见，google 的权威 NS 服务器有四个。</p>
<h4 id="mx">MX</h4>
<p>MX（MX record），邮件交换记录，用于邮件服务器的地址。MX 记录允许设置优先级，当多个邮件服务器可用时，会根据该值决定投递邮件的服务器（值小的优先），下面的<code>20, 10, 40 ...</code>就表示优先级。</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell">$ dig MX google.com
google.com.		306	IN	MX	<span class="m">20</span> alt1.aspmx.l.google.com.
google.com.		306	IN	MX	<span class="m">10</span> aspmx.l.google.com.
google.com.		306	IN	MX	<span class="m">40</span> alt3.aspmx.l.google.com.
google.com.		306	IN	MX	<span class="m">30</span> alt2.aspmx.l.google.com.
google.com.		306	IN	MX	<span class="m">50</span> alt4.aspmx.l.google.com.
</code></pre></div><h4 id="soa">SOA</h4>
<p>SOA 叫做起始授权机构记录，NS用于标识多台域名解析服务器，SOA记录用于在众多NS记录中的<strong>主服务器</strong>。SOA 记录表示此域名的权威解析服务器地址。 当要查询的域名在所有递归解析服务器中没有域名解析的缓存时，就会回源来请求此域名的SOA记录，也叫权威解析记录。</p>
<p>没有SOA记录的 zone 不符合 RFC 1035 要求的标准。</p>
<pre><code>$TTL 86400
@   IN  SOA     startech60serve root.startech60serve.com. (
        2018110201  ;Serial
        3600        ;Refresh
        1800        ;Retry
        604800      ;Expire
        86400       ;Minimum TTL
)
        IN  NS      startech60serve
        IN  A       192.168.1.3
        IN  MX 10   startech60serve
startech60serve     IN  A       192.168.1.3
</code></pre><p><code>root.startech60serve.com. </code>其中第一个点表示是@</p>
<h4 id="txt">TXT</h4>
<p>TXT（TXT record），文本记录，一般用来描述一个域名，或者用来做某种验证功能，例如：</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">$ dig TXT google.com
google.com.		300	IN	TXT	<span class="s2">&#34;docusign=05958488-4752-4ef2-95eb-aa7ba8a3bd0e&#34;</span>
google.com.		3600	IN	TXT	<span class="s2">&#34;facebook-domain-verification=22rm551cu4k0ab0bxsw536tlds4h95&#34;</span>
google.com.		300	IN	TXT	<span class="s2">&#34;docusign=1b0a6754-49b1-4db5-8540-d2c12664b289&#34;</span>
google.com.		3600	IN	TXT	<span class="s2">&#34;globalsign-smime-dv=CDYX+XFHUw2wml6/Gb8+59BsH31KzUr6c1l2BPvqKX8=&#34;</span>
google.com.		3600	IN	TXT	<span class="s2">&#34;v=spf1 include:_spf.google.com ~all&#34;</span>
</code></pre></div><h4 id="ptr">PTR</h4>
<p>PTR 记录是 A 记录的逆向记录，又称做 IP 反查记录或指针记录，负责将 IP 反向解析为域名，即反向域名解析。</p>
<p>参考：</p>
<p><a href="https://skyao.io/learning-dns/dns/">https://skyao.io/learning-dns/dns/</a></p>
<p><a href="https://deepzz.com/post/dns-recording-type.html">https://deepzz.com/post/dns-recording-type.html</a></p>
]]></content>
		</item>
		
		<item>
			<title>如何设计与实现 WebConsole</title>
			<link>https://wangzeping722.github.io/posts/how-to-write-webconsole/</link>
			<pubDate>Wed, 04 Dec 2019 09:13:51 +0800</pubDate>
			
			<guid>https://wangzeping722.github.io/posts/how-to-write-webconsole/</guid>
			<description>1. 调研 前端：了解到有一个非常优秀的开源web终端库： xterm.js , 使用起来也比较简单。 后端：使用 go 语言实现，因为 go 语言拥有许多优秀的开源ssh库，能够</description>
			<content type="html"><![CDATA[<h3 id="1-调研">1. 调研</h3>
<p>前端：了解到有一个非常优秀的开源web终端库： <strong>xterm.js</strong> , 使用起来也比较简单。</p>
<p>后端：使用 go 语言实现，因为 go 语言拥有许多优秀的开源ssh库，能够满足我们的需求。</p>
<p>难点：</p>
<pre><code>1. 如何与 cf(cloud foundry) 进行交互得到 `ssh code` ？
2. 如何把 ssh 命令行转换成 websocket 通讯, 并输出到 xterm.js 中？
3. 如何控制访问权限？
</code></pre>
<h3 id="2-原理">2. 原理</h3>
<p><img src="webconsole1.png" alt="webconsole原理图"></p>
<p>​	1. 浏览器向服务器发起 websocket 请求</p>
<p>​	2. 服务器通过 ssh 连接到 cf 容器</p>
<p>​	3. 连接建立，服务器负责转发消息</p>
<p>在后端和浏览器之间建立websocket连接后，将用户在浏览器中输入的命令通过 websocket 协议发送到后端，后端使用 ssh 协议将命令输入到容器ssh进程的 stdin，命令执行后，再从 stdout 中读取输出，通过websocket协议返回浏览器显示给用户，达到交互的目的。</p>
<h3 id="3-问题解决以及服务端实现">3. 问题解决以及服务端实现</h3>
<p>在前两个步骤中，我已经通过分析把原理和难点梳理清楚了，目前就需要着手解决这些问题。</p>
<h4 id="31-如何获取-ssh-code">3.1 如何获取 ssh code</h4>
<p>cf 有一个自带的命令 <code>cf ssh-code</code> 能够获取连接到容器用的 <code>ssh code</code>，但是我并没有在 cf 开源的 go 语言客户端 <code>cfclient</code> 中发现相关的 API，所以我去查看了 cf cli 的源码，并在里面发现了 <strong>cc</strong> 暴露出来的接口，有了这个接口之后，就能够通过 http 请求的方式获取 <code>ssh-code</code>。由于 <code>cfclient</code> 中并没有相关的代码，所以不得不自己实现一些方来获取 <code>ssh-code</code>, 于是这个问题解决了。</p>
<h4 id="32-如何将-websocket-和-ssh-这两个协议的消息进行转换">3.2 如何将 websocket 和 ssh 这两个协议的消息进行转换</h4>
<p><strong>连接建立</strong>：</p>
<p><img src="webconsole2.png" alt=""></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">WS</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 初始化websocket连接
</span><span class="c1"></span>	<span class="nx">upgrader</span> <span class="o">:=</span> <span class="nx">websocket</span><span class="p">.</span><span class="nx">Upgrader</span><span class="p">{</span>
		<span class="nx">ReadBufferSize</span><span class="p">:</span>  <span class="mi">1024</span><span class="p">,</span>
		<span class="nx">WriteBufferSize</span><span class="p">:</span> <span class="mi">1024</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="nx">ws</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">upgrader</span><span class="p">.</span><span class="nf">Upgrade</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Request</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="k">defer</span> <span class="nx">ws</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
  
	<span class="c1">// 初始化ssh连接
</span><span class="c1"></span>	<span class="nx">cl</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;claims&#34;</span><span class="p">)</span>
	<span class="nx">s</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">&#34;session&#34;</span><span class="p">)</span>
	<span class="nx">claims</span> <span class="o">:=</span> <span class="nx">cl</span><span class="p">.(</span><span class="o">*</span><span class="nx">utils</span><span class="p">.</span><span class="nx">Claims</span><span class="p">)</span>
	<span class="nx">session</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.(</span><span class="o">*</span><span class="nx">utils</span><span class="p">.</span><span class="nx">Session</span><span class="p">)</span>

	<span class="nx">sshShell</span> <span class="o">:=</span> <span class="nx">utils</span><span class="p">.</span><span class="nx">SSHShellSession</span><span class="p">{</span>
		<span class="nx">Node</span><span class="p">:</span> <span class="nx">utils</span><span class="p">.</span><span class="nx">Node</span><span class="p">{</span>
			<span class="nx">Host</span><span class="p">:</span> <span class="nx">claims</span><span class="p">.</span><span class="nx">Host</span><span class="p">,</span>
			<span class="nx">Port</span><span class="p">:</span> <span class="nx">claims</span><span class="p">.</span><span class="nx">Port</span><span class="p">,</span>
		<span class="p">},</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">wsBuff</span> <span class="nx">WebSocketBufferWriter</span>
	<span class="nx">sshShell</span><span class="p">.</span><span class="nx">StdoutPipe</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">wsBuff</span>
	<span class="nx">err</span> <span class="p">=</span> <span class="nx">sshConn</span><span class="p">.</span><span class="nf">Connect</span><span class="p">(</span><span class="nx">username</span><span class="p">,</span> <span class="nx">password</span><span class="p">)</span>
	<span class="k">defer</span> <span class="nx">sshConn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">wsBuff</span><span class="p">.</span><span class="nf">Flush</span><span class="p">(</span><span class="nx">websocket</span><span class="p">.</span><span class="nx">TextMessage</span><span class="p">,</span> <span class="nx">ws</span><span class="p">)</span>
	<span class="o">......</span>
  <span class="o">......</span>
<span class="p">}</span>
</code></pre></div><p><strong>连接保持：</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">WS</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">......</span>
  <span class="o">......</span>
	<span class="nx">done</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
	<span class="nx">setDone</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nx">done</span> <span class="o">&lt;-</span> <span class="kc">true</span> <span class="p">}</span>

	<span class="c1">// 数据转换：websocket ----&gt; SSH
</span><span class="c1"></span>	<span class="nx">writeMessageToSSHServer</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">wc</span> <span class="nx">io</span><span class="p">.</span><span class="nx">WriteCloser</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="nf">setDone</span><span class="p">()</span>
		<span class="k">for</span> <span class="p">{</span>
			<span class="c1">// 从websocket读取数据
</span><span class="c1"></span>			<span class="nx">msgType</span><span class="p">,</span> <span class="nx">p</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ws</span><span class="p">.</span><span class="nf">ReadMessage</span><span class="p">()</span>

			<span class="k">if</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">DispatchMessage</span><span class="p">(</span><span class="nx">sshShell</span><span class="p">.</span><span class="nx">Session</span><span class="p">,</span> <span class="nx">msgType</span><span class="p">,</span> <span class="nx">p</span><span class="p">,</span> <span class="nx">wc</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Error: error write data to ssh server:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
				<span class="k">return</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nx">stopper</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">)</span>
	<span class="c1">// 数据转换：SSH ----&gt; websocket
</span><span class="c1"></span>	<span class="nx">writeBufferToWebSocket</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="nf">setDone</span><span class="p">()</span>
		<span class="nx">tick</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTicker</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="nx">utils</span><span class="p">.</span><span class="nx">Config</span><span class="p">.</span><span class="nx">SSH</span><span class="p">.</span><span class="nx">BufferCheckerCycleTime</span><span class="p">))</span>
		<span class="k">defer</span> <span class="nx">tick</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>
		<span class="k">for</span> <span class="p">{</span>
			<span class="k">select</span> <span class="p">{</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">tick</span><span class="p">.</span><span class="nx">C</span><span class="p">:</span>
				<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">wsBuff</span><span class="p">.</span><span class="nf">Flush</span><span class="p">(</span><span class="nx">websocket</span><span class="p">.</span><span class="nx">TextMessage</span><span class="p">,</span> <span class="nx">ws</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Error: error sending data via webSocket:&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
					<span class="k">return</span>
				<span class="p">}</span>
			<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">stopper</span><span class="p">:</span>
				<span class="k">return</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">go</span> <span class="nf">writeMessageToSSHServer</span><span class="p">(</span><span class="nx">sshShell</span><span class="p">.</span><span class="nx">StdinPipe</span><span class="p">)</span>
	<span class="k">go</span> <span class="nf">writeBufferToWebSocket</span><span class="p">()</span>
	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="nf">setDone</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">sshShell</span><span class="p">.</span><span class="nx">Session</span><span class="p">.</span><span class="nf">Wait</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">{</span>
			<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;ssh exist from server&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}()</span>

	<span class="o">&lt;-</span><span class="nx">done</span>
	<span class="nx">stopper</span> <span class="o">&lt;-</span> <span class="kc">true</span> 
	<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Info: websocket finished!&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p><strong>控制访问权限</strong>：</p>
<p>利用 cf 自带的权限认证机制实现。</p>
]]></content>
		</item>
		
	</channel>
</rss>
